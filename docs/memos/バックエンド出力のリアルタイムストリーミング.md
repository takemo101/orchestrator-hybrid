# バックエンド出力のリアルタイムストリーミング

## 背景

現在、`orch logs`コマンドはorchestrator-hybrid自体のログを表示するが、**バックエンド（opencode/claude）の出力はリアルタイムで確認できない**。

ユーザーは実行中のAIエージェントが何をしているか把握できず、長時間の実行時に不安になる。

## 現状の問題

### exec.tsの実装

```typescript
// src/core/exec.ts
const proc = Bun.spawn([cmd, ...args], {
  stdout: "pipe",  // バッファリング
  stderr: "pipe",
});

const stdout = await new Response(proc.stdout).text();  // 完了後に一括取得
```

### 問題点

| 問題 | 影響 |
|------|------|
| 完了まで出力が見えない | ユーザーが進捗を確認できない |
| 長時間実行時の不安 | 動いているのかフリーズしているのか不明 |
| デバッグ困難 | エラー発生時に途中経過が分からない |
| `logs --follow`が機能しない | バックエンド出力がログファイルに書かれない |

## 提案: リアルタイムストリーミング

### 1. exec.tsの改修

```typescript
// src/core/exec.ts
export interface ExecOptions {
  reject?: boolean;
  onStdout?: (chunk: string) => void;  // 新規: stdoutコールバック
  onStderr?: (chunk: string) => void;  // 新規: stderrコールバック
  logFile?: string;                     // 新規: ログファイルパス
}

export async function exec(
  cmd: string,
  args: string[],
  options: ExecOptions = {},
): Promise<ExecResult> {
  const { reject = true, onStdout, onStderr, logFile } = options;

  const proc = Bun.spawn([cmd, ...args], {
    stdout: "pipe",
    stderr: "pipe",
  });

  let stdout = "";
  let stderr = "";

  // ログファイル書き込み準備
  const logWriter = logFile ? Bun.file(logFile).writer() : null;

  // stdoutのストリーミング処理
  const stdoutReader = proc.stdout.getReader();
  const decoder = new TextDecoder();
  
  while (true) {
    const { done, value } = await stdoutReader.read();
    if (done) break;
    
    const chunk = decoder.decode(value);
    stdout += chunk;
    
    // コールバック実行
    onStdout?.(chunk);
    
    // ファイルに書き込み
    if (logWriter) {
      logWriter.write(value);
      logWriter.flush();
    }
  }

  // stderr処理（同様）
  const stderrReader = proc.stderr.getReader();
  while (true) {
    const { done, value } = await stderrReader.read();
    if (done) break;
    
    const chunk = decoder.decode(value);
    stderr += chunk;
    onStderr?.(chunk);
  }

  if (logWriter) {
    await logWriter.end();
  }

  const exitCode = await proc.exited;

  if (reject && exitCode !== 0) {
    throw new Error(`Command failed with exit code ${exitCode}: ${stderr || stdout}`);
  }

  return { stdout, exitCode };
}
```

### 2. バックエンドアダプターの改修

```typescript
// src/adapters/claude.ts
export class ClaudeBackend extends BaseBackend {
  private logDir?: string;

  setLogDir(dir: string) {
    this.logDir = dir;
  }

  async execute(prompt: string): Promise<BackendResult> {
    const logFile = this.logDir 
      ? `${this.logDir}/backend.log`
      : undefined;

    const { stdout, exitCode } = await exec(
      "claude",
      ["-p", prompt, "--allowedTools", "Edit,Write,Bash,Read,Glob,Grep"],
      { 
        reject: false,
        logFile,
        onStdout: (chunk) => {
          // オプション: リアルタイムでターミナルにも表示
          if (process.env.ORCH_VERBOSE) {
            process.stdout.write(chunk);
          }
        },
      },
    );

    return { output: stdout, exitCode };
  }
}
```

### 3. ログディレクトリ構成

```
.agent/
├── task-1234567890-42/
│   ├── task.log           # orchestrator-hybridのログ（既存）
│   ├── backend.log        # バックエンド出力（新規）
│   └── events.jsonl       # イベント履歴
```

### 4. logsコマンドの拡張

```bash
# バックエンド出力をリアルタイム監視
orch logs --task <id> --follow --backend

# または --source オプションで切り替え
orch logs --task <id> --follow --source backend  # バックエンド出力
orch logs --task <id> --follow --source orch     # orchestratorログ
orch logs --task <id> --follow --source all      # 両方（デフォルト）
```

## 実装に必要な変更

| ファイル | 変更内容 | 工数 |
|---------|---------|------|
| `src/core/exec.ts` | ストリーミング対応 | 2時間 |
| `src/adapters/base.ts` | `setLogDir`メソッド追加 | 30分 |
| `src/adapters/claude.ts` | ログファイル書き込み | 1時間 |
| `src/adapters/opencode.ts` | 同上 | 1時間 |
| `src/core/loop.ts` | バックエンドにlogDir設定 | 30分 |
| `src/cli.ts` | `--source`オプション追加 | 1時間 |
| `src/core/log-streamer.ts` | backend.log対応 | 1時間 |
| テスト | 各ファイルのテスト更新 | 3時間 |

**合計**: 約10時間

## 追加検討事項

### 1. 出力のフィルタリング

バックエンド出力には大量のノイズが含まれる可能性：
- ANSIエスケープシーケンス
- プログレスバー
- 重複した出力

フィルタリングオプションを検討：
```bash
orch logs --task <id> --follow --backend --no-ansi
```

### 2. 出力サイズの制限

長時間実行時にbackend.logが巨大化する可能性：
- ローテーション機能
- 最大サイズ制限
- 古いログの自動削除

### 3. 複数バックエンドの同時監視

並列実行時に複数タスクのバックエンド出力を同時監視：
```bash
orch logs --follow --all-tasks --backend
```

## 関連ファイル

- `src/core/exec.ts` - プロセス実行
- `src/adapters/claude.ts` - Claudeバックエンド
- `src/adapters/opencode.ts` - OpenCodeバックエンド
- `src/core/log-writer.ts` - ログ書き込み
- `src/core/log-streamer.ts` - ログ読み取り
- `src/cli.ts` - logsコマンド

## 優先度

**高** - ユーザー体験に直結する機能。実行中に何が起きているか分からないのは大きなストレス。
