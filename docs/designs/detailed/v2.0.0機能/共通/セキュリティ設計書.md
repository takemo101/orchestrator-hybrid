# v2.0.0機能 セキュリティ設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-003-COMMON-SECURITY |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連基本設計書 | BASIC-ORCH-003 v1.0.0 |

---

## 1. 概要

v2.0.0で追加される機能（F-101〜F-104, F-201〜F-204）に関するセキュリティ設計を定義します。

---

## 2. セキュリティ要件

### 2.1 基本設計書からの要件

| ID | 要件 | 詳細 |
|----|------|------|
| NFR-S-007 | 環境ファイルの保護 | `.env`等の機密情報をworktreeにコピー時、パーミッション維持 |
| NFR-S-008 | ログファイルの保護 | `backend.log`に機密情報が含まれる可能性を警告 |

### 2.2 v2.0.0追加セキュリティ要件

| ID | 要件 | 対象機能 |
|----|------|---------|
| SEC-020 | 設定ファイル内の機密情報保護 | F-101 |
| SEC-021 | バックエンド出力ログの機密情報マスク | F-103 |
| SEC-022 | worktree間のファイルアクセス分離 | F-201 |
| SEC-023 | 環境メタデータの安全な管理 | F-203 |
| SEC-024 | クリーンアップ時の機密情報削除 | F-204 |

---

## 3. 設定ファイルセキュリティ（F-101）

### 3.1 リスク

`orch.yml`の`run`セクションにデフォルト値を設定することで、意図しない動作（自動PRマージ等）が発生する可能性があります。

### 3.2 対策

#### 3.2.1 危険な設定の警告

```typescript
// src/core/config-merger.ts

const DANGEROUS_DEFAULTS = [
  { key: "run.auto_merge", warning: "auto_mergeがデフォルトで有効です。PRが自動的にマージされます。" },
  { key: "run.create_pr", warning: "create_prがデフォルトで有効です。PRが自動的に作成されます。" },
];

export function validateRunConfig(config: RunConfig): void {
  for (const { key, warning } of DANGEROUS_DEFAULTS) {
    const keys = key.split(".");
    let value: unknown = config;
    for (const k of keys.slice(1)) {
      value = (value as Record<string, unknown>)?.[k];
    }
    
    if (value === true) {
      logger.warn(`[セキュリティ警告] ${warning}`);
    }
  }
}
```

#### 3.2.2 CLIオプションの優先

CLIオプションは常に設定ファイルより優先されます。これにより、ユーザーは明示的に設定を上書きできます。

```typescript
// 優先度: CLI > 設定ファイル > デフォルト値
export function mergeConfig(
  cliOptions: Partial<RunConfig>,
  fileConfig: Partial<RunConfig>,
  defaults: RunConfig
): RunConfig {
  return {
    ...defaults,
    ...fileConfig,
    ...cliOptions, // CLIが最優先
  };
}
```

#### 3.2.3 .gitignoreへの設定ファイル追加（オプション）

機密情報を含む設定ファイルは.gitignoreに追加することを推奨:

```gitignore
# 機密情報を含む可能性のある設定ファイル
orch.local.yml
orch.secret.yml
```

---

## 4. バックエンド出力ログセキュリティ（F-103）

### 4.1 リスク

AIエージェントの出力には、以下の機密情報が含まれる可能性があります:

- APIキー
- パスワード
- 環境変数
- 個人情報

### 4.2 対策

#### 4.2.1 リアルタイムマスク処理

```typescript
// src/core/backend-output-streamer.ts

const SENSITIVE_PATTERNS = [
  { pattern: /ghp_[a-zA-Z0-9]{36}/g, replacement: "[GH_TOKEN]" },
  { pattern: /gho_[a-zA-Z0-9]{36}/g, replacement: "[GH_TOKEN]" },
  { pattern: /github_pat_[a-zA-Z0-9_]{22,}/g, replacement: "[GH_PAT]" },
  { pattern: /sk-[a-zA-Z0-9]{48}/g, replacement: "[API_KEY]" },
  { pattern: /OPENAI_API_KEY\s*[=:]\s*\S+/gi, replacement: "OPENAI_API_KEY=[MASKED]" },
  { pattern: /ANTHROPIC_API_KEY\s*[=:]\s*\S+/gi, replacement: "ANTHROPIC_API_KEY=[MASKED]" },
  { pattern: /password\s*[=:]\s*\S+/gi, replacement: "password=[MASKED]" },
  { pattern: /secret\s*[=:]\s*\S+/gi, replacement: "secret=[MASKED]" },
  { pattern: /token\s*[=:]\s*\S+/gi, replacement: "token=[MASKED]" },
  { pattern: /Bearer\s+[a-zA-Z0-9._-]+/gi, replacement: "Bearer [MASKED]" },
];

export function maskSensitiveData(text: string): string {
  let masked = text;
  for (const { pattern, replacement } of SENSITIVE_PATTERNS) {
    masked = masked.replace(pattern, replacement);
  }
  return masked;
}

// ストリーミング書き込み時にマスク処理
async function writeToBackendLog(
  chunk: Uint8Array,
  logPath: string
): Promise<void> {
  const text = new TextDecoder().decode(chunk);
  const maskedText = maskSensitiveData(text);
  await fs.appendFile(logPath, maskedText);
}
```

#### 4.2.2 ログファイルのパーミッション

```typescript
// ログディレクトリ作成時にパーミッション設定
async function createLogDirectory(logDir: string): Promise<void> {
  await fs.mkdir(logDir, { recursive: true, mode: 0o700 });
}

// ログファイル作成時にパーミッション設定
async function createLogFile(logPath: string): Promise<void> {
  const fd = await fs.open(logPath, "w", 0o600);
  await fd.close();
}
```

#### 4.2.3 .gitignoreへの追加

```gitignore
# バックエンド出力ログ（機密情報を含む可能性あり）
.agent/*/backend.log
.agent/*/backend.log.*
```

### 4.3 ログ閲覧時の警告

```typescript
// logs --source backend コマンド実行時の警告
export function warnAboutSensitiveLog(): void {
  logger.warn(
    "backend.logには機密情報が含まれている可能性があります。" +
    "共有する前に内容を確認してください。"
  );
}
```

---

## 5. worktreeセキュリティ（F-201, F-202）

### 5.1 リスク

- worktree間でのファイルアクセス
- 環境ファイル（.env）の漏洩
- シンボリックリンクを介した意図しないファイルアクセス

### 5.2 対策

#### 5.2.1 worktreeディレクトリのパーミッション

```typescript
// worktree作成時のパーミッション設定
async function createWorktree(path: string, branch: string): Promise<void> {
  // git worktree作成
  await exec("git", ["worktree", "add", "-b", branch, path]);
  
  // ディレクトリパーミッション設定
  await fs.chmod(path, 0o700);
  
  // .agentディレクトリのパーミッション設定
  const agentDir = join(path, ".agent");
  await fs.mkdir(agentDir, { recursive: true, mode: 0o700 });
}
```

#### 5.2.2 環境ファイルコピー時のパーミッション維持

```typescript
// 環境ファイルのコピー（パーミッション維持）
async function copyEnvFiles(
  sourcePath: string,
  targetPath: string,
  envFiles: string[]
): Promise<void> {
  for (const envFile of envFiles) {
    const source = join(sourcePath, envFile);
    const target = join(targetPath, envFile);
    
    try {
      const stats = await fs.stat(source);
      await fs.copyFile(source, target);
      // 元のパーミッションを維持
      await fs.chmod(target, stats.mode);
    } catch (error) {
      // ファイルが存在しない場合はスキップ
      if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
        throw error;
      }
    }
  }
}
```

#### 5.2.3 シンボリックリンクの安全性

```typescript
// シンボリックリンク作成時の検証
async function createSafeSymlink(
  source: string,
  target: string,
  allowedBasePath: string
): Promise<void> {
  // ソースパスの正規化
  const resolvedSource = path.resolve(source);
  const resolvedBase = path.resolve(allowedBasePath);
  
  // パストラバーサル防止
  if (!resolvedSource.startsWith(resolvedBase)) {
    throw new WorktreeManagerError(
      `シンボリックリンクのソースが許可されたパス外です: ${source}`,
      { source, allowedBasePath }
    );
  }
  
  // 相対パスでシンボリックリンク作成
  const relativePath = path.relative(path.dirname(target), source);
  await fs.symlink(relativePath, target);
}
```

#### 5.2.4 worktree間のファイル分離

| ファイル | 共有方式 | 理由 |
|---------|---------|------|
| `.agent/memories.md` | シンボリックリンク | 学習内容の共有 |
| `.agent/scratchpad.md` | 独立 | タスク固有の状態 |
| `.agent/tasks.jsonl` | 独立 | タスク固有の進捗 |
| `.env` | コピー | 環境固有の設定 |
| `.envrc` | コピー | 環境固有の設定 |

---

## 6. 環境状態管理セキュリティ（F-203）

### 6.1 リスク

- GitHub Issueメタデータの改ざん
- 機密情報のメタデータへの漏洩
- 不正なラベル操作

### 6.2 対策

#### 6.2.1 メタデータのバリデーション

```typescript
// メタデータの読み込み時に検証
export function parseEnvironmentMetadata(
  issueBody: string
): EnvironmentStateMetadata | null {
  const match = issueBody.match(/<!-- ORCH_ENV_STATE\n([\s\S]*?)\n-->/);
  
  if (!match) {
    return null;
  }
  
  try {
    const metadata = JSON.parse(match[1]);
    
    // フィールドのバリデーション
    if (metadata.worktreePath && !isValidPath(metadata.worktreePath)) {
      throw new Error("不正なworktreePath");
    }
    if (metadata.environmentId && !isValidEnvironmentId(metadata.environmentId)) {
      throw new Error("不正なenvironmentId");
    }
    
    return metadata;
  } catch (error) {
    logger.warn(`環境メタデータの解析に失敗: ${error.message}`);
    return null;
  }
}

function isValidPath(path: string): boolean {
  // パストラバーサル防止
  return !path.includes("..") && path.startsWith(".worktrees/");
}

function isValidEnvironmentId(id: string): boolean {
  // UUID形式または安全な文字のみ
  return /^[a-zA-Z0-9_-]+$/.test(id);
}
```

#### 6.2.2 メタデータへの機密情報排除

```typescript
// メタデータに保存する前に機密情報を除外
export function sanitizeMetadata(
  metadata: EnvironmentStateMetadata
): EnvironmentStateMetadata {
  return {
    worktreePath: metadata.worktreePath,
    branch: metadata.branch,
    environmentType: metadata.environmentType,
    environmentId: metadata.environmentId,
    lastUpdated: metadata.lastUpdated,
    // 機密情報は含めない
    // - 環境変数
    // - APIキー
    // - パスワード
  };
}
```

#### 6.2.3 ラベル操作の権限確認

```typescript
// ラベル操作前に権限確認
async function updateIssueLabel(
  issueNumber: number,
  label: EnvironmentStateLabel
): Promise<void> {
  // ラベル名の検証
  if (!Object.values(EnvironmentStateLabelSchema.enum).includes(label)) {
    throw new EnvironmentStateError(
      `無効なラベル: ${label}`,
      { issueNumber, label }
    );
  }
  
  // GitHub API経由でラベル更新
  await exec("gh", ["issue", "edit", String(issueNumber), "--add-label", label]);
}
```

---

## 7. クリーンアップセキュリティ（F-204）

### 7.1 リスク

- クリーンアップ時の機密ファイル残留
- 意図しないファイル削除
- 不完全なクリーンアップによる情報漏洩

### 7.2 対策

#### 7.2.1 機密ファイルの完全削除

```typescript
// 機密ファイルの安全な削除
async function secureDelete(filePath: string): Promise<void> {
  try {
    // ファイルが存在するか確認
    const stats = await fs.stat(filePath);
    
    if (stats.isFile()) {
      // ファイル内容をゼロで上書き（オプション）
      const zeros = Buffer.alloc(stats.size);
      await fs.writeFile(filePath, zeros);
      
      // ファイル削除
      await fs.unlink(filePath);
    }
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
      throw error;
    }
  }
}

// worktree削除前に機密ファイルを削除
async function cleanupSensitiveFiles(worktreePath: string): Promise<void> {
  const sensitiveFiles = [
    ".env",
    ".env.local",
    ".envrc",
    ".agent/memories.md", // シンボリックリンクの場合はリンクのみ削除
  ];
  
  for (const file of sensitiveFiles) {
    const filePath = join(worktreePath, file);
    const stats = await fs.lstat(filePath).catch(() => null);
    
    if (stats?.isSymbolicLink()) {
      // シンボリックリンクは単純に削除
      await fs.unlink(filePath);
    } else if (stats?.isFile()) {
      // 通常ファイルは安全に削除
      await secureDelete(filePath);
    }
  }
}
```

#### 7.2.2 削除対象の検証

```typescript
// 削除前にパスの安全性を検証
function validateDeletePath(path: string, allowedBasePaths: string[]): void {
  const resolvedPath = resolve(path);
  
  const isAllowed = allowedBasePaths.some(
    basePath => resolvedPath.startsWith(resolve(basePath))
  );
  
  if (!isAllowed) {
    throw new WorktreeManagerError(
      `削除が許可されていないパス: ${path}`,
      { path, allowedBasePaths }
    );
  }
}

// 使用例
const ALLOWED_DELETE_PATHS = [".worktrees/", ".agent/"];

async function safeRemoveWorktree(worktreePath: string): Promise<void> {
  validateDeletePath(worktreePath, ALLOWED_DELETE_PATHS);
  await cleanupSensitiveFiles(worktreePath);
  await exec("git", ["worktree", "remove", "--force", worktreePath]);
}
```

#### 7.2.3 クリーンアップログの記録

```typescript
// クリーンアップ操作の監査ログ
async function logCleanupOperation(result: CleanupResult): Promise<void> {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event: "cleanup",
    data: {
      issueNumber: result.issueNumber,
      success: result.success,
      deletedWorktree: result.deletedWorktree,
      deletedBranch: result.deletedBranch,
      deletedEnvironmentType: result.deletedEnvironmentType,
      // environmentIdは記録しない（機密性）
      error: result.error,
    },
  };
  
  logger.info(JSON.stringify(logEntry));
}
```

---

## 8. GitHub API セキュリティ

### 8.1 トークン管理

v1.3.0で実装済みのトークン管理をv2.0.0でも継続使用:

- `gh` CLI経由でのトークン管理
- 環境変数`GH_TOKEN`によるトークン指定
- トークンのログ出力禁止

### 8.2 Rate Limit対策

| 認証状態 | 制限 | 時間 |
|---------|------|------|
| 認証済み | 5,000リクエスト | 1時間 |
| 未認証 | 60リクエスト | 1時間 |

v2.0.0では環境状態管理（F-203）でAPIコールが増加するため、以下の対策を実装:

```typescript
// APIコールの最小化
let cachedIssueData: Map<number, { data: Issue; timestamp: number }> = new Map();
const CACHE_TTL_MS = 60000; // 1分

async function getIssueWithCache(issueNumber: number): Promise<Issue> {
  const cached = cachedIssueData.get(issueNumber);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL_MS) {
    return cached.data;
  }
  
  const data = await fetchIssue(issueNumber);
  cachedIssueData.set(issueNumber, { data, timestamp: Date.now() });
  
  return data;
}
```

---

## 9. ファイルシステムセキュリティ

### 9.1 パーミッション一覧

| ファイル/ディレクトリ | 権限 | 説明 |
|---------------------|------|------|
| `.worktrees/` | 700 | 所有者のみアクセス可能 |
| `.worktrees/<issue>/` | 700 | 所有者のみアクセス可能 |
| `.worktrees/<issue>/.env` | 600 | 所有者のみ読み書き可能 |
| `.agent/` | 700 | 所有者のみアクセス可能 |
| `.agent/*/backend.log` | 600 | 所有者のみ読み書き可能 |
| `.orch/` | 700 | 所有者のみアクセス可能 |
| `.orch/worktrees.json` | 600 | 所有者のみ読み書き可能 |
| `orch.yml` | 644 | 全員読み取り可能 |

### 9.2 パストラバーサル防止

```typescript
// すべてのファイル操作でパストラバーサルを防止
function securePath(basePath: string, userPath: string): string {
  const resolved = path.resolve(basePath, userPath);
  const baseResolved = path.resolve(basePath);
  
  if (!resolved.startsWith(baseResolved + path.sep) && resolved !== baseResolved) {
    throw new Error(`パストラバーサルを検出: ${userPath}`);
  }
  
  return resolved;
}
```

---

## 10. 監査ログ

### 10.1 v2.0.0で追加される監査対象

| イベント | 記録内容 | 対象機能 |
|---------|---------|---------|
| config.merge | マージされた設定キー | F-101 |
| backend.log.rotate | ローテーションしたファイル | F-103 |
| worktree.create | パス、ブランチ、環境タイプ | F-201 |
| worktree.remove | パス、結果 | F-201 |
| environment.create | 環境タイプ、環境ID | F-202 |
| environment.delete | 環境タイプ | F-204 |
| state.label.update | Issue番号、新旧ラベル | F-203 |
| cleanup.complete | Issue番号、削除対象 | F-204 |

### 10.2 ログフォーマット

```json
{
  "timestamp": "2026-01-26T10:30:00Z",
  "level": "info",
  "event": "worktree.create",
  "data": {
    "path": ".worktrees/issue-42",
    "branch": "feature/issue-42",
    "environmentType": "container-use"
  }
}
```

---

## 11. セキュリティチェックリスト

### 11.1 開発時チェック（v2.0.0追加項目）

- [ ] 設定ファイルに機密情報が直接記載されていないか
- [ ] バックエンド出力ログに機密情報がマスクされているか
- [ ] worktree作成時にパーミッションが正しく設定されているか
- [ ] 環境メタデータに機密情報が含まれていないか
- [ ] クリーンアップ時に機密ファイルが完全に削除されているか

### 11.2 レビュー時チェック（v2.0.0追加項目）

- [ ] パストラバーサル対策が実装されているか
- [ ] 削除操作に対象パス検証があるか
- [ ] シンボリックリンクが安全に作成されているか
- [ ] APIキャッシュが適切に実装されているか

### 11.3 リリース前チェック

- [ ] `.gitignore`に機密ファイルが含まれているか
- [ ] 新規追加されたファイルの権限設定が適切か
- [ ] 監査ログが正しく記録されているか
- [ ] 危険な設定のデフォルト値に対する警告が実装されているか

---

## 12. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
