# バックエンド出力ストリーミング バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-003-F103-BE |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-003-F103 |
| 対象機能 | F-103 |

---

## 1. 概要

バックエンド出力ストリーミング機能のバックエンド実装仕様を定義します。

---

## 2. ファイル構成

| ファイル | 説明 | 新規/変更 |
|---------|------|----------|
| `src/core/backend-output-streamer.ts` | BackendOutputStreamerクラス | 新規 |
| `src/core/backend-output-streamer.test.ts` | 単体テスト | 新規 |
| `src/adapters/base.ts` | BackendOutputStreamer統合 | 変更 |
| `src/adapters/claude.ts` | ストリーミング有効化 | 変更 |
| `src/adapters/opencode.ts` | ストリーミング有効化 | 変更 |

---

## 3. クラス詳細設計

### 3.1 BackendOutputStreamer

#### ファイル: `src/core/backend-output-streamer.ts`

```typescript
import { existsSync, mkdirSync, writeFileSync } from "node:fs";
import { appendFile } from "node:fs/promises";
import { dirname } from "node:path";
import { logger } from "./logger.js";

/**
 * BackendOutputStreamer設定
 */
export interface BackendOutputStreamerConfig {
  /**
   * ログファイルパス
   */
  logPath: string;

  /**
   * タイムスタンプを付与するか
   * @default true
   */
  includeTimestamp?: boolean;

  /**
   * バッファサイズ（バイト）
   * @default 4096
   */
  bufferSize?: number;
}

/**
 * ログエントリ
 */
interface LogEntry {
  timestamp: string;
  stream: "stdout" | "stderr";
  content: string;
}

/**
 * バックエンド出力をリアルタイムでログファイルに書き込むクラス
 * 
 * @example
 * ```typescript
 * const streamer = new BackendOutputStreamer({
 *   logPath: ".agent/task-123/backend.log",
 * });
 * 
 * // AIエージェントの出力をキャプチャ
 * process.stdout.on("data", (data) => {
 *   streamer.writeStdout(data);
 * });
 * 
 * process.stderr.on("data", (data) => {
 *   streamer.writeStderr(data);
 * });
 * 
 * // 終了時
 * streamer.close();
 * ```
 */
export class BackendOutputStreamer {
  private readonly config: Required<BackendOutputStreamerConfig>;
  private buffer: string[] = [];
  private closed = false;

  constructor(config: BackendOutputStreamerConfig) {
    this.config = {
      includeTimestamp: config.includeTimestamp ?? true,
      bufferSize: config.bufferSize ?? 4096,
      logPath: config.logPath,
    };

    this.ensureLogDirectory();
    this.initializeLogFile();
  }

  /**
   * stdoutデータを書き込む
   * 
   * @param data - データ
   */
  writeStdout(data: string | Buffer): void {
    this.write("stdout", data);
  }

  /**
   * stderrデータを書き込む
   * 
   * @param data - データ
   */
  writeStderr(data: string | Buffer): void {
    this.write("stderr", data);
  }

  /**
   * ストリーマーを閉じる
   */
  async close(): Promise<void> {
    if (this.closed) {
      return;
    }

    await this.flush();
    this.closed = true;
  }

  /**
   * データを書き込む（内部メソッド）
   * 
   * @param stream - stdout | stderr
   * @param data - データ
   */
  private write(stream: "stdout" | "stderr", data: string | Buffer): void {
    if (this.closed) {
      logger.warn("BackendOutputStreamer is closed, ignoring write");
      return;
    }

    const content = typeof data === "string" ? data : data.toString("utf-8");
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      stream,
      content: content.trim(),
    };

    const formatted = this.formatLogEntry(entry);
    this.buffer.push(formatted);

    // バッファサイズに達したらフラッシュ（非同期、待機しない）
    const bufferSize = this.buffer.reduce((sum, line) => sum + line.length, 0);
    if (bufferSize >= this.config.bufferSize) {
      void this.flush(); // fire-and-forget（非ブロッキング）
    }
  }

  /**
   * ログエントリをフォーマット
   * 
   * @param entry - ログエントリ
   * @returns フォーマット済み文字列
   */
  private formatLogEntry(entry: LogEntry): string {
    if (this.config.includeTimestamp) {
      return `[${entry.timestamp}] [${entry.stream}] ${entry.content}\n`;
    }
    return `[${entry.stream}] ${entry.content}\n`;
  }

  /**
   * バッファをファイルに書き込む（非同期）
   * 
   * 詳細設計書の「非ブロッキング」原則に準拠し、
   * イベントループをブロックしない非同期I/Oを使用。
   */
  private async flush(): Promise<void> {
    if (this.buffer.length === 0) {
      return;
    }

    const content = this.buffer.join("");
    this.buffer = [];

    try {
      await appendFile(this.config.logPath, content, "utf-8");
    } catch (error) {
      logger.warn(`Failed to write to backend.log: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * ログディレクトリを作成
   */
  private ensureLogDirectory(): void {
    const dir = dirname(this.config.logPath);
    if (!existsSync(dir)) {
      try {
        mkdirSync(dir, { recursive: true });
      } catch (error) {
        logger.error(`Failed to create log directory: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
      }
    }
  }

  /**
   * ログファイルを初期化
   */
  private initializeLogFile(): void {
    try {
      // ファイルが存在しない場合は作成
      if (!existsSync(this.config.logPath)) {
        writeFileSync(this.config.logPath, "", "utf-8");
      }
    } catch (error) {
      logger.error(`Failed to initialize log file: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
}
```

---

## 4. メソッド詳細

### 4.1 constructor

```typescript
constructor(config: BackendOutputStreamerConfig)
```

**責務**: BackendOutputStreamerを初期化する

**引数**:
- `config.logPath`: ログファイルパス
- `config.includeTimestamp`: タイムスタンプを付与するか（デフォルト: true）
- `config.bufferSize`: バッファサイズ（デフォルト: 4096バイト）

**処理フロー**:
1. 設定をマージ（デフォルト値適用）
2. ログディレクトリを作成
3. ログファイルを初期化

### 4.2 writeStdout

```typescript
writeStdout(data: string | Buffer): void
```

**責務**: stdoutデータをログファイルに書き込む

**引数**:
- `data`: 標準出力データ

**処理フロー**:
1. データを文字列に変換
2. ログエントリを作成（タイムスタンプ、[stdout]タグ付き）
3. バッファに追加
4. バッファサイズが閾値を超えたらフラッシュ

### 4.3 writeStderr

```typescript
writeStderr(data: string | Buffer): void
```

**責務**: stderrデータをログファイルに書き込む

**引数**:
- `data`: 標準エラー出力データ

**処理フロー**:
- `writeStdout`と同様（[stderr]タグ）

### 4.4 close

```typescript
close(): void
```

**責務**: ストリーマーを閉じる

**処理フロー**:
1. バッファをフラッシュ
2. `closed`フラグをtrueに設定

### 4.5 flush (private)

```typescript
private async flush(): Promise<void>
```

**責務**: バッファをファイルに非同期で書き込む

**処理フロー**:
1. バッファが空の場合は何もしない
2. バッファを結合して文字列化
3. バッファをクリア（書き込み前にクリアして競合を防止）
4. `appendFile`（非同期版）でファイルに追記

**設計原則**:
- **非ブロッキング**: 詳細設計書の原則に準拠し、`appendFileSync`ではなく`appendFile`を使用
- イベントループをブロックしないため、大量ログ時もAIエージェントのパフォーマンスに影響しない

**エラー処理**:
- 書き込み失敗時は警告ログを出力し、処理は継続

---

## 5. 型定義

### 5.1 BackendOutputStreamerConfig

```typescript
export interface BackendOutputStreamerConfig {
  logPath: string;
  includeTimestamp?: boolean;
  bufferSize?: number;
}
```

### 5.2 LogEntry (private)

```typescript
interface LogEntry {
  timestamp: string;      // ISO 8601形式
  stream: "stdout" | "stderr";
  content: string;
}
```

---

## 6. BackendAdapterとの統合

### 6.1 BaseBackendAdapter拡張

```typescript
// src/adapters/base.ts

import { BackendOutputStreamer } from "../core/backend-output-streamer.js";

export abstract class BaseBackendAdapter {
  protected streamer?: BackendOutputStreamer;

  protected setupOutputStreaming(logPath: string): void {
    this.streamer = new BackendOutputStreamer({ logPath });
  }

  protected handleStdout(data: Buffer): void {
    this.streamer?.writeStdout(data);
  }

  protected handleStderr(data: Buffer): void {
    this.streamer?.writeStderr(data);
  }

  protected closeStreaming(): void {
    this.streamer?.close();
  }
}
```

### 6.2 ClaudeAdapter統合

```typescript
// src/adapters/claude.ts

export class ClaudeAdapter extends BaseBackendAdapter {
  async execute(context: LoopContext): Promise<ProcessResult> {
    const logPath = join(context.logDir, "backend.log");
    this.setupOutputStreaming(logPath);

    const proc = Bun.spawn(["claude", ...args], {
      stdout: "pipe",
      stderr: "pipe",
    });

    // stdoutをキャプチャ
    proc.stdout.on("data", (data) => {
      this.handleStdout(data);
    });

    // stderrをキャプチャ
    proc.stderr.on("data", (data) => {
      this.handleStderr(data);
    });

    await proc.exited;
    this.closeStreaming();

    return { exitCode: proc.exitCode };
  }
}
```

---

## 7. テスト方針

### 7.1 単体テスト

#### ファイル: `src/core/backend-output-streamer.test.ts`

```typescript
import { describe, expect, it, beforeEach, afterEach } from "bun:test";
import { existsSync, mkdirSync, readFileSync, rmSync } from "node:fs";
import { BackendOutputStreamer } from "./backend-output-streamer.js";

const TEST_DIR = ".test-backend-output";
const TEST_LOG_PATH = `${TEST_DIR}/backend.log`;

describe("BackendOutputStreamer", () => {
  beforeEach(() => {
    if (existsSync(TEST_DIR)) {
      rmSync(TEST_DIR, { recursive: true });
    }
    mkdirSync(TEST_DIR, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(TEST_DIR)) {
      rmSync(TEST_DIR, { recursive: true });
    }
  });

  describe("constructor", () => {
    it("should create log directory if not exists", () => {
      const nestedPath = `${TEST_DIR}/nested/dir/backend.log`;
      new BackendOutputStreamer({ logPath: nestedPath });
      expect(existsSync(`${TEST_DIR}/nested/dir`)).toBe(true);
    });

    it("should initialize log file", () => {
      new BackendOutputStreamer({ logPath: TEST_LOG_PATH });
      expect(existsSync(TEST_LOG_PATH)).toBe(true);
    });
  });

  describe("writeStdout", () => {
    it("should write stdout data with timestamp", () => {
      const streamer = new BackendOutputStreamer({
        logPath: TEST_LOG_PATH,
        includeTimestamp: true,
      });

      streamer.writeStdout("Hello, World!");
      streamer.close();

      const content = readFileSync(TEST_LOG_PATH, "utf-8");
      expect(content).toMatch(/\[\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z\] \[stdout\] Hello, World!/);
    });

    it("should write stdout data without timestamp", () => {
      const streamer = new BackendOutputStreamer({
        logPath: TEST_LOG_PATH,
        includeTimestamp: false,
      });

      streamer.writeStdout("Hello, World!");
      streamer.close();

      const content = readFileSync(TEST_LOG_PATH, "utf-8");
      expect(content).toBe("[stdout] Hello, World!\n");
    });

    it("should handle Buffer input", () => {
      const streamer = new BackendOutputStreamer({
        logPath: TEST_LOG_PATH,
        includeTimestamp: false,
      });

      streamer.writeStdout(Buffer.from("Buffer data"));
      streamer.close();

      const content = readFileSync(TEST_LOG_PATH, "utf-8");
      expect(content).toContain("[stdout] Buffer data");
    });
  });

  describe("writeStderr", () => {
    it("should write stderr data", () => {
      const streamer = new BackendOutputStreamer({
        logPath: TEST_LOG_PATH,
        includeTimestamp: false,
      });

      streamer.writeStderr("Error occurred");
      streamer.close();

      const content = readFileSync(TEST_LOG_PATH, "utf-8");
      expect(content).toBe("[stderr] Error occurred\n");
    });
  });

  describe("buffering", () => {
    it("should flush buffer when size exceeds threshold", () => {
      const streamer = new BackendOutputStreamer({
        logPath: TEST_LOG_PATH,
        bufferSize: 100, // 小さいバッファサイズ
      });

      // 100バイトを超えるデータを書き込む
      for (let i = 0; i < 10; i++) {
        streamer.writeStdout(`Line ${i}\n`);
      }

      // バッファがフラッシュされているはず
      const content = readFileSync(TEST_LOG_PATH, "utf-8");
      expect(content.length).toBeGreaterThan(0);
    });
  });

  describe("close", () => {
    it("should flush buffer on close", () => {
      const streamer = new BackendOutputStreamer({
        logPath: TEST_LOG_PATH,
        bufferSize: 10000, // 大きいバッファサイズ
      });

      streamer.writeStdout("Test");
      streamer.close();

      const content = readFileSync(TEST_LOG_PATH, "utf-8");
      expect(content).toContain("[stdout] Test");
    });

    it("should ignore writes after close", () => {
      const streamer = new BackendOutputStreamer({
        logPath: TEST_LOG_PATH,
      });

      streamer.close();
      streamer.writeStdout("Should be ignored");

      const content = readFileSync(TEST_LOG_PATH, "utf-8");
      expect(content).toBe("");
    });
  });
});
```

---

## 8. 変更履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|-----------|------|----------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
