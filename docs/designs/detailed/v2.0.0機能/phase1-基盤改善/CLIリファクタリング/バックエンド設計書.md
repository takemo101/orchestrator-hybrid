# CLIリファクタリング バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-003-F102-BE |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-003-F102 |
| 対象機能 | F-102 |

---

## 1. 概要

CLIリファクタリング機能のバックエンド実装仕様を定義します。

---

## 2. ファイル構成

| ファイル | 説明 | 新規/変更 |
|---------|------|----------|
| `src/cli.ts` | エントリーポイント（100行以下） | 変更 |
| `src/cli/commands/types.ts` | 共通型定義 | 新規 |
| `src/cli/commands/run.ts` | runコマンド | 新規 |
| `src/cli/commands/init.ts` | initコマンド | 新規 |
| `src/cli/commands/logs.ts` | logsコマンド | 新規 |
| `src/cli/commands/status.ts` | statusコマンド | 新規 |
| `src/cli/commands/events.ts` | eventsコマンド | 新規 |
| `src/cli/commands/cancel.ts` | cancelコマンド | 新規 |
| `src/cli/commands/clear.ts` | clearコマンド | 新規 |
| `src/cli/utils/preset-loader.ts` | プリセット読み込み | 新規 |
| `src/cli/utils/config-loader.ts` | 設定読み込み | 新規 |
| `src/cli-logs.ts` | ログヘルパー（削除予定） | 削除 |

---

## 3. クラス詳細設計

### 3.1 cli.ts（エントリーポイント）

#### ファイル: `src/cli.ts`

```typescript
#!/usr/bin/env node

import { dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { Command } from "commander";
import { CancelCommand } from "./cli/commands/cancel.js";
import { ClearCommand } from "./cli/commands/clear.js";
import { EventsCommand } from "./cli/commands/events.js";
import { InitCommand } from "./cli/commands/init.js";
import { LogsCommand } from "./cli/commands/logs.js";
import { RunCommand } from "./cli/commands/run.js";
import { StatusCommand } from "./cli/commands/status.js";

const __dirname = dirname(fileURLToPath(import.meta.url));

const program = new Command();

program
  .name("orch")
  .description("AI agent orchestrator combining Ralph loop with GitHub Issue integration")
  .version("0.1.0");

// コマンド登録
new RunCommand().register(program);
new InitCommand().register(program);
new LogsCommand().register(program);
new StatusCommand().register(program);
new EventsCommand().register(program);
new CancelCommand().register(program);
new ClearCommand().register(program);

program.parse();
```

---

### 3.2 RunCommand

#### ファイル: `src/cli/commands/run.ts`

```typescript
import type { Command } from "commander";
import { logger, setVerbose } from "../../core/logger.js";
import { runLoop, runMultipleLoops } from "../../core/loop.js";
import type { PRConfig } from "../../core/types.js";
import type { CommandHandler } from "./types.js";
import { loadConfigWithMerge } from "../utils/config-loader.js";
import { loadPreset } from "../utils/preset-loader.js";

export interface RunCommandOptions {
  issue?: string;
  issues?: string;
  backend?: string;
  preset?: string;
  maxIterations?: number;
  auto?: boolean;
  createPr?: boolean;
  draft?: boolean;
  container?: boolean;
  autoMerge?: boolean;
  resolveDeps?: boolean;
  ignoreDeps?: boolean;
  report?: string | boolean;
  config?: string;
  verbose?: boolean;
}

/**
 * runコマンドハンドラー
 */
export class RunCommand implements CommandHandler {
  register(program: Command): void {
    program
      .command("run")
      .description("Start orchestration loop")
      .option("-i, --issue <number>", "GitHub issue number (single)")
      .option("--issues <numbers>", "GitHub issue numbers (comma-separated for parallel)")
      .option("-b, --backend <type>", "Backend: claude, opencode")
      .option("-p, --preset <name>", "Use preset configuration (tdd, spec-driven, simple)")
      .option("-m, --max-iterations <number>", "Maximum iterations", Number.parseInt)
      .option("-a, --auto", "Auto-approve all gates")
      .option("--create-pr", "Create PR after completion")
      .option("--draft", "Create PR as draft")
      .option("--container", "Run in isolated container-use environment")
      .option("--auto-merge", "Auto-merge PR after CI passes")
      .option("--resolve-deps", "Resolve and run dependency issues first")
      .option("--ignore-deps", "Ignore issue dependencies")
      .option("--report [path]", "Generate execution report (default: .agent/report.md)")
      .option("-c, --config <path>", "Config file path")
      .option("-v, --verbose", "Verbose output")
      .action(async (options: RunCommandOptions) => {
        try {
          await this.execute(options);
        } catch (error) {
          logger.error(error instanceof Error ? error.message : String(error));
          process.exit(1);
        }
      });
  }

  async execute(options: RunCommandOptions): Promise<void> {
    if (options.verbose) {
      setVerbose(true);
    }

    if (!options.issue && !options.issues) {
      throw new Error("Either --issue or --issues is required");
    }

    // 設定読み込み（プリセット優先）
    let config = options.preset
      ? loadPreset(options.preset)
      : loadConfigWithMerge(options);

    // バックエンド上書き
    if (options.backend) {
      config.backend.type = options.backend as "claude" | "opencode" | "gemini" | "container";
    }

    // PR設定構築
    const prConfig: PRConfig = {
      auto_merge: options.autoMerge ?? config.pr?.auto_merge ?? false,
      merge_method: config.pr?.merge_method ?? "squash",
      delete_branch: config.pr?.delete_branch ?? true,
      ci_timeout_secs: config.pr?.ci_timeout_secs ?? 600,
    };

    // 依存関係設定構築
    const depConfig = {
      resolveDeps: options.resolveDeps ?? config.dependency?.resolve ?? false,
      ignoreDeps: options.ignoreDeps ?? config.dependency?.ignore ?? false,
    };

    // 単一/並列実行
    if (options.issues) {
      await this.executeMultiple(options, config, prConfig, depConfig);
    } else {
      await this.executeSingle(options, config, prConfig, depConfig);
    }
  }

  private async executeSingle(
    options: RunCommandOptions,
    config: any,
    prConfig: PRConfig,
    depConfig: { resolveDeps: boolean; ignoreDeps: boolean }
  ): Promise<void> {
    const issueNumber = Number.parseInt(options.issue!, 10);
    if (Number.isNaN(issueNumber)) {
      throw new Error(`Invalid issue number: ${options.issue}`);
    }

    await runLoop({
      issueNumber,
      config,
      autoApprove: options.auto ?? config.run?.auto_mode ?? false,
      maxIterations: options.maxIterations ?? config.loop?.max_iterations,
      createPR: options.createPr ?? config.run?.create_pr ?? false,
      draftPR: options.draft ?? config.run?.draft_pr ?? false,
      useContainer: options.container ?? config.container?.enabled ?? false,
      generateReport: options.report !== undefined,
      reportPath: typeof options.report === "string" ? options.report : undefined,
      prConfig,
      resolveDeps: depConfig.resolveDeps,
      ignoreDeps: depConfig.ignoreDeps,
    });
  }

  private async executeMultiple(
    options: RunCommandOptions,
    config: any,
    prConfig: PRConfig,
    depConfig: { resolveDeps: boolean; ignoreDeps: boolean }
  ): Promise<void> {
    const issueNumbers = (options.issues ?? "")
      .split(",")
      .map((n: string) => Number.parseInt(n.trim(), 10))
      .filter((n: number) => !Number.isNaN(n));

    if (issueNumbers.length === 0) {
      throw new Error("No valid issue numbers provided");
    }

    logger.info(`Starting parallel execution for issues: ${issueNumbers.join(", ")}`);

    await runMultipleLoops({
      issueNumbers,
      config,
      autoApprove: options.auto ?? config.run?.auto_mode ?? false,
      maxIterations: options.maxIterations ?? config.loop?.max_iterations,
      createPR: options.createPr ?? config.run?.create_pr ?? false,
      draftPR: options.draft ?? config.run?.draft_pr ?? false,
      useContainer: options.container ?? config.container?.enabled ?? false,
      generateReport: options.report !== undefined,
      reportPath: typeof options.report === "string" ? options.report : undefined,
      prConfig,
      resolveDeps: depConfig.resolveDeps,
      ignoreDeps: depConfig.ignoreDeps,
    });
  }
}
```

---

### 3.3 InitCommand

#### ファイル: `src/cli/commands/init.ts`

```typescript
import type { Command } from "commander";
import { existsSync, writeFileSync } from "node:fs";
import chalk from "chalk";
import { logger } from "../../core/logger.js";
import { IssueStatusLabelManager } from "../../output/issue-status-label-manager.js";
import type { CommandHandler } from "./types.js";
import { loadPreset } from "../utils/preset-loader.js";

export interface InitCommandOptions {
  preset?: string;
  listPresets?: boolean;
  labels?: boolean;
}

/**
 * initコマンドハンドラー
 */
export class InitCommand implements CommandHandler {
  register(program: Command): void {
    program
      .command("init")
      .description("Initialize configuration file")
      .option("-p, --preset <name>", "Use preset configuration")
      .option("--list-presets", "List available presets")
      .option("--labels", "Create status labels in repository")
      .action(async (options: InitCommandOptions) => {
        try {
          await this.execute(options);
        } catch (error) {
          logger.error(error instanceof Error ? error.message : String(error));
          process.exit(1);
        }
      });
  }

  async execute(options: InitCommandOptions): Promise<void> {
    if (options.listPresets) {
      this.listPresets();
      return;
    }

    if (options.labels) {
      await this.createLabels();
      return;
    }

    await this.initializeConfig(options.preset);
  }

  private listPresets(): void {
    logger.info("Available presets:");
    logger.info("  - simple: Simple loop without hats");
    logger.info("  - tdd: Test-driven development (Red-Green-Refactor)");
    logger.info("  - spec-driven: Specification-driven development (Plan-Build-Review)");
  }

  private async createLabels(): Promise<void> {
    logger.info("Creating status labels in repository...");
    const manager = new IssueStatusLabelManager({
      enabled: true,
      label_prefix: "orch",
    });
    await manager.initializeLabels();
    logger.info(chalk.green("✓ Status labels created successfully"));
  }

  private async initializeConfig(preset?: string): Promise<void> {
    const configPath = "orch.yml";

    if (existsSync(configPath)) {
      logger.warn(`Config file already exists: ${configPath}`);
      return;
    }

    let content: string;
    if (preset) {
      logger.info(`Initializing with preset: ${preset}`);
      const config = loadPreset(preset);
      content = this.configToYaml(config);
    } else {
      content = this.getDefaultConfig();
    }

    writeFileSync(configPath, content);
    logger.info(chalk.green(`✓ Created ${configPath}`));
  }

  private getDefaultConfig(): string {
    return `version: "1.0"

backend:
  type: claude
  model: claude-sonnet-4-20250514

run:
  auto_mode: false
  create_pr: false
  draft_pr: false

loop:
  max_iterations: 100
  completion_promise: "LOOP_COMPLETE"
  idle_timeout_secs: 1800

gates:
  after_plan: true
  after_implementation: false
  before_pr: true

pr:
  auto_merge: false
  merge_method: squash
  delete_branch: true
  ci_timeout_secs: 600

state:
  use_github_labels: true
  label_prefix: "orch"
  use_scratchpad: true
  scratchpad_path: ".agent/scratchpad.md"
`;
  }

  private configToYaml(config: any): string {
    // 簡易的なYAML変換（実際にはyamlライブラリを使用）
    return JSON.stringify(config, null, 2);
  }
}
```

---

### 3.4 LogsCommand

#### ファイル: `src/cli/commands/logs.ts`

```typescript
import type { Command } from "commander";
import { existsSync, readFileSync } from "node:fs";
import { join } from "node:path";
import chalk from "chalk";
import { LogStreamer } from "../../core/log-streamer.js";
import { logger } from "../../core/logger.js";
import { TaskStore } from "../../core/task-manager.js";
import type { CommandHandler } from "./types.js";

export interface LogsCommandOptions {
  task?: string;
  follow?: boolean;
  lines?: number;
  table?: boolean;
  interval?: number;
}

/**
 * logsコマンドハンドラー
 */
export class LogsCommand implements CommandHandler {
  register(program: Command): void {
    program
      .command("logs")
      .description("View task logs")
      .option("-t, --task <id>", "Task ID")
      .option("-f, --follow", "Follow log output")
      .option("-n, --lines <num>", "Number of lines to show", Number.parseInt, 100)
      .option("--table", "Show task status table (legacy mode)")
      .option("--interval <ms>", "Table update interval in ms", Number.parseInt, 1000)
      .action(async (options: LogsCommandOptions) => {
        try {
          await this.execute(options);
        } catch (error) {
          logger.error(error instanceof Error ? error.message : String(error));
          process.exit(1);
        }
      });
  }

  async execute(options: LogsCommandOptions): Promise<void> {
    if (options.table) {
      await this.showTable(options.interval ?? 1000);
      return;
    }

    if (!options.task) {
      throw new Error("--task is required (or use --table for legacy mode)");
    }

    const logPath = this.findTaskLogPath(options.task);
    if (!logPath) {
      throw new Error(`Log file not found for task: ${options.task}`);
    }

    if (options.follow) {
      await this.followLog(logPath);
    } else {
      this.showLastLines(logPath, options.lines ?? 100);
    }
  }

  private findTaskLogPath(taskId: string): string | null {
    const baseDir = ".agent";
    const logPath = join(baseDir, taskId, "task.log");
    return existsSync(logPath) ? logPath : null;
  }

  private async followLog(logPath: string): Promise<void> {
    logger.info(`Following log: ${logPath}`);
    const streamer = new LogStreamer(logPath, { follow: true });

    await streamer.stream((line) => {
      console.log(line);
    });
  }

  private showLastLines(logPath: string, lines: number): void {
    const content = readFileSync(logPath, "utf-8");
    const allLines = content.split("\n");
    const lastLines = allLines.slice(-lines);
    console.log(lastLines.join("\n"));
  }

  private async showTable(interval: number): Promise<void> {
    // レガシーモード: タスク状態テーブル表示
    const store = new TaskStore();
    const tasks = store.loadAll();

    console.clear();
    console.log(chalk.bold("Task Status Table"));
    console.log("Press Ctrl+C to exit\n");

    // テーブル表示ロジック（既存のcli.tsから移植）
    // ...
  }
}
```

---

## 4. メソッド詳細

### 4.1 CommandHandler.register

```typescript
register(program: Command): void
```

**責務**: commanderプログラムにコマンドを登録する

**引数**:
- `program`: commanderプログラムインスタンス

**処理フロー**:
1. `program.command()`でコマンド定義
2. `.option()`でオプション定義
3. `.action()`でハンドラー登録

### 4.2 CommandHandler.execute

```typescript
async execute(options: CommandOptions): Promise<void>
```

**責務**: コマンドのビジネスロジックを実行する

**引数**:
- `options`: コマンドオプション

**処理フロー**:
- コマンドごとに異なる（詳細は各コマンドのクラス設計を参照）

---

## 5. 型定義

### 5.1 CommandHandler

```typescript
// src/cli/commands/types.ts

import type { Command } from "commander";

/**
 * コマンドハンドラーインターフェース
 */
export interface CommandHandler {
  /**
   * コマンドを登録する
   * 
   * @param program - commanderプログラム
   */
  register(program: Command): void;
}
```

---

## 6. テスト方針

### 6.1 単体テスト

#### ファイル: `src/cli/commands/run.test.ts`

```typescript
import { describe, expect, it, mock } from "bun:test";
import { RunCommand } from "./run.js";

describe("RunCommand", () => {
  it("should throw error when no issue specified", async () => {
    const command = new RunCommand();
    await expect(command.execute({})).rejects.toThrow(
      "Either --issue or --issues is required"
    );
  });

  it("should parse single issue number", async () => {
    const runLoop = mock(() => Promise.resolve());
    const command = new RunCommand();
    // 依存性注入でrunLoopをモック化
    // ...
  });

  it("should parse multiple issue numbers", async () => {
    const command = new RunCommand();
    const options = { issues: "42,43,44" };
    // ...
  });
});
```

---

## 7. 変更履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|-----------|------|----------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
