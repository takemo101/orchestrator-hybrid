# logsコマンド拡張 バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-003-F104-BE |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-003-F104 |
| 対象機能 | F-104 |

---

## 1. 概要

logsコマンド拡張機能のバックエンド実装仕様を定義します。

---

## 2. ファイル構成

| ファイル | 説明 | 新規/変更 |
|---------|------|----------|
| `src/cli/commands/logs.ts` | logsコマンド（`--source`追加） | 変更 |
| `src/cli/commands/logs.test.ts` | 単体テスト | 変更 |
| `src/cli/commands/types.ts` | LogSource型追加 | 変更 |

---

## 3. クラス詳細設計

### 3.1 LogsCommand（拡張）

#### ファイル: `src/cli/commands/logs.ts`

```typescript
import type { Command } from "commander";
import { existsSync, readFileSync } from "node:fs";
import { join } from "node:path";
import chalk from "chalk";
import { LogStreamer } from "../../core/log-streamer.js";
import { logger } from "../../core/logger.js";
import { TaskStore } from "../../core/task-manager.js";
import type { CommandHandler, LogSource } from "./types.js";

export interface LogsCommandOptions {
  task?: string;
  source?: LogSource;  // 新規追加
  follow?: boolean;
  lines?: number;
  table?: boolean;
  interval?: number;
}

/**
 * logsコマンドハンドラー
 */
export class LogsCommand implements CommandHandler {
  register(program: Command): void {
    program
      .command("logs")
      .description("View task logs")
      .option("-t, --task <id>", "Task ID")
      .option("-s, --source <type>", "Log source: task | backend", "task")  // 新規追加
      .option("-f, --follow", "Follow log output")
      .option("-n, --lines <num>", "Number of lines to show", Number.parseInt, 100)
      .option("--table", "Show task status table (legacy mode)")
      .option("--interval <ms>", "Table update interval in ms", Number.parseInt, 1000)
      .action(async (options: LogsCommandOptions) => {
        try {
          await this.execute(options);
        } catch (error) {
          logger.error(error instanceof Error ? error.message : String(error));
          process.exit(1);
        }
      });
  }

  async execute(options: LogsCommandOptions): Promise<void> {
    if (options.table) {
      await this.showTable(options.interval ?? 1000);
      return;
    }

    if (!options.task) {
      throw new Error("--task is required (or use --table for legacy mode)");
    }

    // ログソースのバリデーション
    const source = this.validateLogSource(options.source);

    const logPath = this.findLogPath(options.task, source);
    if (!logPath) {
      throw new Error(`Log file not found for task: ${options.task}, source: ${source}`);
    }

    if (options.follow) {
      await this.followLog(logPath, source);
    } else {
      this.showLastLines(logPath, options.lines ?? 100, source);
    }
  }

  /**
   * ログソースをバリデーション
   * 
   * @param source - ログソース
   * @returns バリデーション済みログソース
   */
  private validateLogSource(source?: string): LogSource {
    if (!source) {
      return "task"; // デフォルト
    }

    if (source !== "task" && source !== "backend") {
      throw new Error(`Invalid log source: ${source}. Must be 'task' or 'backend'`);
    }

    return source;
  }

  /**
   * ログファイルパスを取得
   * 
   * @param taskId - タスクID
   * @param source - ログソース
   * @returns ログファイルパス（存在しない場合はnull）
   */
  private findLogPath(taskId: string, source: LogSource): string | null {
    const baseDir = ".agent";
    const logFileName = source === "backend" ? "backend.log" : "task.log";
    const logPath = join(baseDir, taskId, logFileName);
    return existsSync(logPath) ? logPath : null;
  }

  /**
   * ログをリアルタイムで監視
   * 
   * @param logPath - ログファイルパス
   * @param source - ログソース
   */
  private async followLog(logPath: string, source: LogSource): Promise<void> {
    logger.info(`Following ${source} log: ${logPath}`);
    logger.info(chalk.gray("Press Ctrl+C to stop\n"));

    const streamer = new LogStreamer(logPath, { follow: true });

    await streamer.stream((line) => {
      console.log(line);
    });
  }

  /**
   * 最後のN行を表示
   * 
   * @param logPath - ログファイルパス
   * @param lines - 表示行数
   * @param source - ログソース
   */
  private showLastLines(logPath: string, lines: number, source: LogSource): void {
    logger.info(`Showing last ${lines} lines of ${source} log: ${logPath}\n`);

    const content = readFileSync(logPath, "utf-8");
    const allLines = content.split("\n");
    const lastLines = allLines.slice(-lines);
    console.log(lastLines.join("\n"));
  }

  /**
   * タスク状態テーブルを表示（レガシーモード）
   * 
   * @param interval - 更新間隔（ミリ秒）
   */
  private async showTable(interval: number): Promise<void> {
    const store = new TaskStore();

    console.clear();
    console.log(chalk.bold("Task Status Table"));
    console.log(chalk.gray("Press Ctrl+C to exit\n"));

    const updateTable = () => {
      const tasks = store.loadAll();

      console.clear();
      console.log(chalk.bold("Task Status Table"));
      console.log(chalk.gray(`Updated: ${new Date().toLocaleTimeString()}\n`));

      if (tasks.length === 0) {
        console.log(chalk.gray("No tasks found"));
        return;
      }

      // テーブルヘッダー
      console.log(
        chalk.bold(
          "Task ID".padEnd(30) +
          "Issue".padEnd(10) +
          "Status".padEnd(15) +
          "Iteration".padEnd(12) +
          "Started"
        )
      );
      console.log("-".repeat(80));

      // タスク一覧
      for (const task of tasks) {
        const statusColor = this.getStatusColor(task.status);
        console.log(
          task.id.padEnd(30) +
          `#${task.issueNumber}`.padEnd(10) +
          chalk[statusColor](task.status.padEnd(15)) +
          `${task.iteration}`.padEnd(12) +
          new Date(task.startedAt).toLocaleTimeString()
        );
      }
    };

    // 初回表示
    updateTable();

    // 定期更新
    const intervalId = setInterval(updateTable, interval);

    // Ctrl+Cで終了
    process.on("SIGINT", () => {
      clearInterval(intervalId);
      console.log("\n" + chalk.gray("Stopped"));
      process.exit(0);
    });
  }

  /**
   * ステータスに応じた色を取得
   * 
   * @param status - タスクステータス
   * @returns chalkカラー名
   */
  private getStatusColor(status: string): "green" | "yellow" | "red" | "gray" {
    switch (status) {
      case "running":
        return "green";
      case "completed":
        return "gray";
      case "failed":
        return "red";
      case "cancelled":
        return "yellow";
      default:
        return "gray";
    }
  }
}
```

---

## 4. メソッド詳細

### 4.1 execute

```typescript
async execute(options: LogsCommandOptions): Promise<void>
```

**責務**: logsコマンドのメインロジックを実行する

**引数**:
- `options.task`: タスクID
- `options.source`: ログソース（`task` | `backend`、デフォルト: `task`）
- `options.follow`: リアルタイム監視フラグ
- `options.lines`: 表示行数
- `options.table`: テーブルモードフラグ

**処理フロー**:
1. テーブルモードの場合は`showTable()`を実行して終了
2. タスクIDが未指定の場合はエラー
3. ログソースをバリデーション
4. ログファイルパスを取得
5. `--follow`フラグに応じて`followLog()`または`showLastLines()`を実行

### 4.2 validateLogSource (private)

```typescript
private validateLogSource(source?: string): LogSource
```

**責務**: ログソースをバリデーションする

**引数**:
- `source`: ログソース文字列

**戻り値**: バリデーション済みログソース（`task` | `backend`）

**処理フロー**:
1. 未指定の場合は`"task"`を返す
2. `"task"`または`"backend"`以外の場合はエラー
3. 有効な値の場合はそのまま返す

### 4.3 findLogPath (private)

```typescript
private findLogPath(taskId: string, source: LogSource): string | null
```

**責務**: ログファイルパスを取得する

**引数**:
- `taskId`: タスクID
- `source`: ログソース

**戻り値**: ログファイルパス（存在しない場合はnull）

**処理フロー**:
1. ログソースに応じてファイル名を決定（`task.log` | `backend.log`）
2. `.agent/<taskId>/<logFileName>`のパスを構築
3. ファイルが存在するか確認
4. 存在する場合はパスを返す、存在しない場合はnullを返す

### 4.4 followLog (private)

```typescript
private async followLog(logPath: string, source: LogSource): Promise<void>
```

**責務**: ログをリアルタイムで監視する

**引数**:
- `logPath`: ログファイルパス
- `source`: ログソース（表示用）

**処理フロー**:
1. 監視開始メッセージを表示
2. LogStreamerを作成（`follow: true`）
3. `stream()`メソッドで各行をコンソールに出力

### 4.5 showLastLines (private)

```typescript
private showLastLines(logPath: string, lines: number, source: LogSource): void
```

**責務**: 最後のN行を表示する

**引数**:
- `logPath`: ログファイルパス
- `lines`: 表示行数
- `source`: ログソース（表示用）

**処理フロー**:
1. ログファイルを読み込む
2. 改行で分割
3. 最後のN行を抽出
4. コンソールに出力

---

## 5. 型定義

### 5.1 LogSource

```typescript
// src/cli/commands/types.ts

/**
 * ログソース
 */
export type LogSource = "task" | "backend";
```

### 5.2 LogsCommandOptions

```typescript
export interface LogsCommandOptions {
  task?: string;
  source?: LogSource;  // 新規追加
  follow?: boolean;
  lines?: number;
  table?: boolean;
  interval?: number;
}
```

---

## 6. テスト方針

### 6.1 単体テスト

#### ファイル: `src/cli/commands/logs.test.ts`

```typescript
import { describe, expect, it, beforeEach, afterEach } from "bun:test";
import { existsSync, mkdirSync, rmSync, writeFileSync } from "node:fs";
import { LogsCommand } from "./logs.js";

const TEST_DIR = ".test-logs";
const TEST_TASK_ID = "task-123";
const TEST_TASK_DIR = `${TEST_DIR}/${TEST_TASK_ID}`;

describe("LogsCommand", () => {
  beforeEach(() => {
    if (existsSync(TEST_DIR)) {
      rmSync(TEST_DIR, { recursive: true });
    }
    mkdirSync(TEST_TASK_DIR, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(TEST_DIR)) {
      rmSync(TEST_DIR, { recursive: true });
    }
  });

  describe("execute", () => {
    it("should throw error when task not specified", async () => {
      const command = new LogsCommand();
      await expect(command.execute({})).rejects.toThrow(
        "--task is required"
      );
    });

    it("should throw error when log file not found", async () => {
      const command = new LogsCommand();
      await expect(
        command.execute({
          task: TEST_TASK_ID,
          source: "backend",
        })
      ).rejects.toThrow("Log file not found");
    });

    it("should throw error when invalid source", async () => {
      const command = new LogsCommand();
      await expect(
        command.execute({
          task: TEST_TASK_ID,
          source: "invalid" as any,
        })
      ).rejects.toThrow("Invalid log source");
    });
  });

  describe("validateLogSource", () => {
    it("should return 'task' when source is undefined", () => {
      const command = new LogsCommand();
      const result = (command as any).validateLogSource(undefined);
      expect(result).toBe("task");
    });

    it("should return 'task' when source is 'task'", () => {
      const command = new LogsCommand();
      const result = (command as any).validateLogSource("task");
      expect(result).toBe("task");
    });

    it("should return 'backend' when source is 'backend'", () => {
      const command = new LogsCommand();
      const result = (command as any).validateLogSource("backend");
      expect(result).toBe("backend");
    });

    it("should throw error when source is invalid", () => {
      const command = new LogsCommand();
      expect(() => {
        (command as any).validateLogSource("invalid");
      }).toThrow("Invalid log source");
    });
  });

  describe("findLogPath", () => {
    it("should return task.log path when source is 'task'", () => {
      writeFileSync(`${TEST_TASK_DIR}/task.log`, "Task log");

      const command = new LogsCommand();
      const result = (command as any).findLogPath(TEST_TASK_ID, "task");
      expect(result).toBe(`${TEST_DIR}/${TEST_TASK_ID}/task.log`);
    });

    it("should return backend.log path when source is 'backend'", () => {
      writeFileSync(`${TEST_TASK_DIR}/backend.log`, "Backend log");

      const command = new LogsCommand();
      const result = (command as any).findLogPath(TEST_TASK_ID, "backend");
      expect(result).toBe(`${TEST_DIR}/${TEST_TASK_ID}/backend.log`);
    });

    it("should return null when log file not found", () => {
      const command = new LogsCommand();
      const result = (command as any).findLogPath(TEST_TASK_ID, "backend");
      expect(result).toBeNull();
    });
  });

  describe("showLastLines", () => {
    it("should display last N lines", () => {
      const logContent = Array.from({ length: 100 }, (_, i) => `Line ${i + 1}`).join("\n");
      writeFileSync(`${TEST_TASK_DIR}/task.log`, logContent);

      const command = new LogsCommand();
      // コンソール出力をキャプチャしてテスト
      // ...
    });
  });
});
```

---

## 7. 変更履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|-----------|------|----------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
