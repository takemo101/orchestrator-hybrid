# Multi-Loop Concurrency バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-004-F017-BE |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-004-F017 |
| 対象機能 | F-017 |

---

## 1. 概要

Multi-Loop Concurrency機能のバックエンド実装仕様を定義します。

---

## 2. ファイル構成

| ファイル | 説明 | 新規/変更 |
|---------|------|----------|
| `src/core/worktree-manager.ts` | WorktreeManagerクラス | 新規 |
| `src/core/loop-registry.ts` | LoopRegistryクラス | 新規 |
| `src/core/auto-merger.ts` | AutoMergerクラス | 新規 |
| `src/core/worktree-manager.test.ts` | 単体テスト | 新規 |
| `src/core/loop-registry.test.ts` | 単体テスト | 新規 |
| `src/core/auto-merger.test.ts` | 単体テスト | 新規 |
| `src/cli.ts` | `orch loops`コマンド追加 | 変更 |
| `src/core/loop.ts` | WorktreeManager統合 | 変更 |

---

## 3. クラス詳細設計

### 3.1 WorktreeManager

#### ファイル: `src/core/worktree-manager.ts`

```typescript
import * as fs from "fs/promises";
import * as path from "path";
import { ProcessExecutor, BunProcessExecutor } from "./process-executor.js";
import { logger } from "./logger.js";

/**
 * Worktree情報
 */
export interface Worktree {
  loopId: string;
  path: string;
  branch: string;
}

/**
 * Worktree管理クラス
 * 
 * @example
 * ```typescript
 * const manager = new WorktreeManager("/path/to/project");
 * 
 * // Worktreeを作成
 * const worktreePath = await manager.createWorktree("orch-20260126-a3f2");
 * 
 * // ループ実行
 * // ...
 * 
 * // Worktreeをマージ
 * await manager.mergeWorktree("orch-20260126-a3f2");
 * 
 * // Worktreeを削除
 * await manager.removeWorktree("orch-20260126-a3f2");
 * ```
 */
export class WorktreeManager {
  private readonly baseDir: string;
  private readonly worktreesDir: string;
  private readonly executor: ProcessExecutor;

  constructor(baseDir: string, executor: ProcessExecutor = new BunProcessExecutor()) {
    this.baseDir = baseDir;
    this.worktreesDir = path.join(baseDir, ".worktrees");
    this.executor = executor;
  }

  /**
   * Worktreeを作成
   * @param loopId - ループID
   * @returns worktreeパス
   */
  async createWorktree(loopId: string): Promise<string> {
    const worktreePath = path.join(this.worktreesDir, loopId);
    const branchName = `loop/${loopId}`;

    try {
      // .worktreesディレクトリを作成
      await fs.mkdir(this.worktreesDir, { recursive: true });

      // git worktree add
      const result = await this.executor.spawn(
        "git",
        ["worktree", "add", "-b", branchName, worktreePath],
        { cwd: this.baseDir }
      );

      if (result.exitCode !== 0) {
        throw new Error(`git worktree add failed: ${result.stderr}`);
      }

      logger.info(`Worktree作成: ${worktreePath}`);

      // .agentディレクトリ作成
      const agentDir = path.join(worktreePath, ".agent");
      await fs.mkdir(agentDir, { recursive: true });

      // memories.mdをシンボリックリンク
      await this.createMemoriesSymlink(worktreePath);

      return worktreePath;
    } catch (error) {
      logger.error(`Worktreeの作成に失敗しました:`, error);
      throw error;
    }
  }

  /**
   * Worktreeを削除
   * @param loopId - ループID
   */
  async removeWorktree(loopId: string): Promise<void> {
    const worktreePath = path.join(this.worktreesDir, loopId);

    try {
      // git worktree remove
      const result = await this.executor.spawn(
        "git",
        ["worktree", "remove", worktreePath, "--force"],
        { cwd: this.baseDir }
      );

      if (result.exitCode !== 0) {
        logger.warn(`git worktree remove failed: ${result.stderr}`);
      }

      logger.info(`Worktree削除: ${worktreePath}`);
    } catch (error) {
      logger.error(`Worktreeの削除に失敗しました:`, error);
      throw error;
    }
  }

  /**
   * すべてのWorktreeを一覧表示
   * @returns Worktree配列
   */
  async listWorktrees(): Promise<Worktree[]> {
    try {
      const result = await this.executor.spawn(
        "git",
        ["worktree", "list", "--porcelain"],
        { cwd: this.baseDir }
      );

      if (result.exitCode !== 0) {
        throw new Error(`git worktree list failed: ${result.stderr}`);
      }

      return this.parseWorktreeList(result.stdout);
    } catch (error) {
      logger.error(`Worktree一覧の取得に失敗しました:`, error);
      return [];
    }
  }

  /**
   * Worktreeをマージ
   * @param loopId - ループID
   * @returns マージ成功時はtrue
   */
  async mergeWorktree(loopId: string): Promise<boolean> {
    const branchName = `loop/${loopId}`;

    try {
      // mainブランチに切り替え
      await this.executor.spawn("git", ["checkout", "main"], { cwd: this.baseDir });

      // マージ
      const result = await this.executor.spawn(
        "git",
        ["merge", branchName, "--no-ff", "-m", `Merge loop ${loopId}`],
        { cwd: this.baseDir }
      );

      if (result.exitCode !== 0) {
        logger.error(`マージに失敗しました: ${result.stderr}`);
        return false;
      }

      logger.success(`Worktreeマージ成功: ${loopId}`);
      return true;
    } catch (error) {
      logger.error(`Worktreeのマージに失敗しました:`, error);
      return false;
    }
  }

  /**
   * memories.mdをシンボリックリンク
   * @param worktreePath - worktreeパス
   */
  private async createMemoriesSymlink(worktreePath: string): Promise<void> {
    const memoriesPath = path.join(worktreePath, ".agent", "memories.md");
    const primaryMemoriesPath = path.join(this.baseDir, ".agent", "memories.md");

    try {
      // プライマリのmemoriesが存在しない場合は作成
      try {
        await fs.access(primaryMemoriesPath);
      } catch {
        await fs.mkdir(path.dirname(primaryMemoriesPath), { recursive: true });
        await fs.writeFile(primaryMemoriesPath, "# Memories\n\n");
      }

      // シンボリックリンク作成
      const relativePath = path.relative(
        path.dirname(memoriesPath),
        primaryMemoriesPath
      );
      await fs.symlink(relativePath, memoriesPath);

      logger.info(`Memoriesをシンボリックリンク: ${memoriesPath}`);
    } catch (error) {
      logger.warn(`Memoriesのシンボリックリンク作成に失敗:`, error);
    }
  }

  /**
   * git worktree list の出力をパース
   * @param output - git worktree list --porcelain の出力
   * @returns Worktree配列
   */
  private parseWorktreeList(output: string): Worktree[] {
    const worktrees: Worktree[] = [];
    const lines = output.trim().split("\n");
    let currentWorktree: Partial<Worktree> = {};

    for (const line of lines) {
      if (line.startsWith("worktree ")) {
        const worktreePath = line.substring(9);
        const loopId = path.basename(worktreePath);
        currentWorktree = { loopId, path: worktreePath };
      } else if (line.startsWith("branch ")) {
        currentWorktree.branch = line.substring(7);
      } else if (line === "") {
        if (currentWorktree.loopId) {
          worktrees.push(currentWorktree as Worktree);
        }
        currentWorktree = {};
      }
    }

    // 最後のWorktreeを追加
    if (currentWorktree.loopId) {
      worktrees.push(currentWorktree as Worktree);
    }

    return worktrees;
  }
}
```

---

### 3.2 LoopRegistry

#### ファイル: `src/core/loop-registry.ts`

```typescript
import * as fs from "fs/promises";
import * as path from "path";
import { logger } from "./logger.js";

/**
 * Loop状態
 */
export type LoopState =
  | "running"
  | "queued"
  | "merging"
  | "merged"
  | "needs-review"
  | "crashed"
  | "orphan"
  | "discarded";

/**
 * Loop
 */
export interface Loop {
  id: string;
  state: LoopState;
  worktree_path: string | null;
  created_at: string;
  updated_at: string;
}

/**
 * ループレジストリ
 */
interface LoopRegistryData {
  loops: Loop[];
}

/**
 * ループレジストリクラス
 * 
 * @example
 * ```typescript
 * const registry = new LoopRegistry("/path/to/project");
 * 
 * // ループを登録
 * await registry.registerLoop({
 *   id: "orch-20260126-a3f2",
 *   state: "running",
 *   worktree_path: ".worktrees/orch-20260126-a3f2",
 *   created_at: new Date().toISOString(),
 *   updated_at: new Date().toISOString(),
 * });
 * 
 * // ループ状態を更新
 * await registry.updateLoopState("orch-20260126-a3f2", "merged");
 * 
 * // すべてのループを取得
 * const loops = await registry.listLoops();
 * ```
 */
export class LoopRegistry {
  private readonly registryPath: string;

  constructor(baseDir: string) {
    this.registryPath = path.join(baseDir, ".orch", "loops.json");
  }

  /**
   * ループを登録
   * @param loop - Loop情報
   */
  async registerLoop(loop: Loop): Promise<void> {
    const data = await this.loadRegistry();
    data.loops.push(loop);
    await this.saveRegistry(data);
    logger.info(`ループ登録: ${loop.id}`);
  }

  /**
   * ループ状態を更新
   * @param loopId - ループID
   * @param state - 新しい状態
   */
  async updateLoopState(loopId: string, state: LoopState): Promise<void> {
    const data = await this.loadRegistry();
    const loop = data.loops.find((l) => l.id === loopId);

    if (!loop) {
      logger.warn(`ループ ${loopId} が見つかりません`);
      return;
    }

    loop.state = state;
    loop.updated_at = new Date().toISOString();

    await this.saveRegistry(data);
    logger.info(`ループ状態更新: ${loopId} -> ${state}`);
  }

  /**
   * すべてのループを取得
   * @returns Loop配列
   */
  async listLoops(): Promise<Loop[]> {
    const data = await this.loadRegistry();
    return data.loops;
  }

  /**
   * ループを削除
   * @param loopId - ループID
   */
  async deleteLoop(loopId: string): Promise<void> {
    const data = await this.loadRegistry();
    data.loops = data.loops.filter((l) => l.id !== loopId);
    await this.saveRegistry(data);
    logger.info(`ループ削除: ${loopId}`);
  }

  /**
   * レジストリを読み込み
   * @returns LoopRegistryData
   */
  private async loadRegistry(): Promise<LoopRegistryData> {
    try {
      const content = await fs.readFile(this.registryPath, "utf-8");
      return JSON.parse(content);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === "ENOENT") {
        // ファイルが存在しない場合は空のレジストリ
        return { loops: [] };
      }
      throw error;
    }
  }

  /**
   * レジストリを保存
   * @param data - LoopRegistryData
   */
  private async saveRegistry(data: LoopRegistryData): Promise<void> {
    await fs.mkdir(path.dirname(this.registryPath), { recursive: true });
    await fs.writeFile(this.registryPath, JSON.stringify(data, null, 2));
  }
}
```

---

### 3.3 AutoMerger

#### ファイル: `src/core/auto-merger.ts`

```typescript
import { ProcessExecutor, BunProcessExecutor } from "./process-executor.js";
import { logger } from "./logger.js";

/**
 * 自動マージクラス
 * 
 * @example
 * ```typescript
 * const merger = new AutoMerger("/path/to/project");
 * const success = await merger.autoMerge("orch-20260126-a3f2");
 * 
 * if (success) {
 *   console.log("マージ成功");
 * } else {
 *   console.log("マージ失敗、手動解決が必要");
 * }
 * ```
 */
export class AutoMerger {
  private readonly baseDir: string;
  private readonly executor: ProcessExecutor;

  constructor(baseDir: string, executor: ProcessExecutor = new BunProcessExecutor()) {
    this.baseDir = baseDir;
    this.executor = executor;
  }

  /**
   * Worktreeを自動マージ
   * @param loopId - ループID
   * @returns マージ成功時はtrue
   */
  async autoMerge(loopId: string): Promise<boolean> {
    const branchName = `loop/${loopId}`;

    try {
      logger.info(`自動マージ開始: ${loopId}`);

      // mainブランチに切り替え
      await this.executor.spawn("git", ["checkout", "main"], { cwd: this.baseDir });

      // マージ
      const result = await this.executor.spawn(
        "git",
        ["merge", branchName, "--no-ff", "-m", `Merge loop ${loopId}`],
        { cwd: this.baseDir }
      );

      if (result.exitCode !== 0) {
        // コンフリクトが発生した場合
        logger.warn(`マージコンフリクトが発生しました: ${loopId}`);
        
        // AI駆動のコンフリクト解決を試行
        const resolved = await this.resolveConflicts(loopId);
        
        if (!resolved) {
          // 解決失敗、マージを中断
          await this.executor.spawn("git", ["merge", "--abort"], { cwd: this.baseDir });
          return false;
        }

        // 解決成功、マージをコミット
        await this.executor.spawn("git", ["commit", "--no-edit"], { cwd: this.baseDir });
      }

      logger.success(`自動マージ成功: ${loopId}`);
      return true;
    } catch (error) {
      logger.error(`自動マージに失敗しました:`, error);
      return false;
    }
  }

  /**
   * AI駆動のコンフリクト解決
   * @param loopId - ループID
   * @returns 解決成功時はtrue
   */
  private async resolveConflicts(loopId: string): Promise<boolean> {
    // TODO: AI駆動のコンフリクト解決を実装
    // 1. コンフリクトファイルを取得
    // 2. AIにコンフリクト解決を依頼
    // 3. 解決結果を適用
    
    logger.warn("AI駆動のコンフリクト解決は未実装です");
    return false;
  }
}
```

---

## 4. CLI統合

### ファイル: `src/cli.ts`（追加分）

```typescript
import { WorktreeManager } from "./core/worktree-manager.js";
import { LoopRegistry } from "./core/loop-registry.js";

program
  .command("loops")
  .description("ループ一覧を表示")
  .action(async () => {
    const registry = new LoopRegistry(".");
    const loops = await registry.listLoops();
    
    console.table(loops);
  });

program
  .command("loops")
  .command("logs <loop-id>")
  .option("-f, --follow", "リアルタイムでログをストリーミング")
  .action(async (loopId, options) => {
    // TODO: ループのログを表示
    logger.info(`ループ ${loopId} のログを表示`);
  });
```

---

## 5. Loop Engine統合

### ファイル: `src/core/loop.ts`（変更分）

```typescript
import { WorktreeManager } from "./worktree-manager.js";
import { LoopRegistry } from "./loop-registry.js";
import { AutoMerger } from "./auto-merger.js";

export async function runLoop(context: LoopContext): Promise<LoopResult> {
  const worktreeManager = new WorktreeManager(context.baseDir);
  const loopRegistry = new LoopRegistry(context.baseDir);
  const autoMerger = new AutoMerger(context.baseDir);
  
  // ループIDを生成
  const loopId = generateLoopId();
  
  // プライマリループかセカンダリループか判定
  const isPrimary = await tryAcquireLock();
  
  let worktreePath: string | null = null;
  
  if (!isPrimary) {
    // セカンダリループ: worktreeを作成
    worktreePath = await worktreeManager.createWorktree(loopId);
    context.baseDir = worktreePath;
  }
  
  // ループを登録
  await loopRegistry.registerLoop({
    id: loopId,
    state: "running",
    worktree_path: worktreePath,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  });
  
  // ループ実行
  const result = await executeLoop(context);
  
  // ループ完了
  if (context.autoMerge && worktreePath) {
    // 自動マージ
    await loopRegistry.updateLoopState(loopId, "merging");
    const success = await autoMerger.autoMerge(loopId);
    
    if (success) {
      await loopRegistry.updateLoopState(loopId, "merged");
      await worktreeManager.removeWorktree(loopId);
    } else {
      await loopRegistry.updateLoopState(loopId, "needs-review");
    }
  } else {
    await loopRegistry.updateLoopState(loopId, "queued");
  }
  
  return result;
}

function generateLoopId(): string {
  const date = new Date().toISOString().split("T")[0].replace(/-/g, "");
  const random = Math.random().toString(36).substring(2, 6);
  return `orch-${date}-${random}`;
}
```

---

## 6. テスト設計

### 6.1 単体テスト

#### ファイル: `src/core/worktree-manager.test.ts`

```typescript
import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { WorktreeManager } from "./worktree-manager.js";
import * as fs from "fs/promises";

const testDir = ".test-project";

beforeEach(async () => {
  await fs.mkdir(testDir, { recursive: true });
  // git init
  // ...
});

afterEach(async () => {
  await fs.rm(testDir, { recursive: true, force: true });
});

describe("WorktreeManager", () => {
  test("Worktreeを作成", async () => {
    const manager = new WorktreeManager(testDir);
    const worktreePath = await manager.createWorktree("test-loop");
    
    const exists = await fs.access(worktreePath).then(() => true).catch(() => false);
    expect(exists).toBe(true);
  });

  test("Memoriesをシンボリックリンク", async () => {
    const manager = new WorktreeManager(testDir);
    const worktreePath = await manager.createWorktree("test-loop");
    
    const memoriesPath = `${worktreePath}/.agent/memories.md`;
    const stats = await fs.lstat(memoriesPath);
    expect(stats.isSymbolicLink()).toBe(true);
  });
});
```

---

## 7. 実装メモ

### 7.1 git worktree

git worktreeを使用してファイルシステムを完全に分離。

### 7.2 シンボリックリンク

memoriesはシンボリックリンクで共有。他のファイル（scratchpad, tasks, events）は分離。

### 7.3 自動マージ

AI駆動のコンフリクト解決は将来の拡張として実装。

---

## 8. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
