# Tasks System バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-004-F015-BE |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-004-F015 |
| 対象機能 | F-015 |

---

## 1. 概要

Tasks System機能のバックエンド実装仕様を定義します。

---

## 2. ファイル構成

| ファイル | 説明 | 新規/変更 |
|---------|------|----------|
| `src/core/task-manager.ts` | TaskManagerクラス | 新規 |
| `src/core/task-manager.test.ts` | 単体テスト | 新規 |
| `src/core/types.ts` | TasksConfigSchema追加 | 変更 |
| `src/cli.ts` | `orch tools task`コマンド追加 | 変更 |
| `src/core/loop.ts` | TaskManager統合 | 変更 |

---

## 3. クラス詳細設計

### 3.1 TaskManager

#### ファイル: `src/core/task-manager.ts`

```typescript
import * as fs from "fs/promises";
import * as path from "path";
import { logger } from "./logger.js";

/**
 * Task状態
 */
export type TaskStatus = "open" | "in-progress" | "closed";

/**
 * Task
 */
export interface Task {
  id: string;
  title: string;
  priority: number;
  status: TaskStatus;
  blocked_by: string[];
  created_at: string;
  updated_at: string;
}

/**
 * Tasks設定
 */
export interface TasksConfig {
  enabled: boolean;
}

/**
 * Task管理クラス
 * 
 * @example
 * ```typescript
 * const manager = new TaskManager({ enabled: true }, ".agent");
 * 
 * // Taskを追加
 * const taskId = await manager.addTask("Add auth", 2);
 * 
 * // readyタスクを取得
 * const ready = await manager.getReadyTasks();
 * 
 * // Task状態を更新
 * await manager.updateStatus(taskId, "in-progress");
 * await manager.updateStatus(taskId, "closed");
 * ```
 */
export class TaskManager {
  private readonly config: TasksConfig;
  private readonly tasksPath: string;
  private taskCounter = 0;

  constructor(config: TasksConfig, baseDir: string) {
    this.config = config;
    this.tasksPath = path.join(baseDir, "tasks.jsonl");
  }

  /**
   * Tasksを読み込み
   * @returns Task配列（最新状態のみ）
   */
  async loadTasks(): Promise<Task[]> {
    if (!this.config.enabled) {
      return [];
    }

    try {
      const content = await fs.readFile(this.tasksPath, "utf-8");
      return this.parseTasks(content);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === "ENOENT") {
        // ファイルが存在しない場合は空配列
        return [];
      }
      
      logger.warn(
        `tasks.jsonlの読み込みに失敗しました。空のtasksとして扱います。`,
        error
      );
      return [];
    }
  }

  /**
   * Taskを追加
   * @param title - タスクタイトル
   * @param priority - 優先度（1-5）
   * @param blockedBy - 依存タスクID配列
   * @returns 生成されたタスクID
   */
  async addTask(
    title: string,
    priority: number = 3,
    blockedBy: string[] = []
  ): Promise<string> {
    if (!this.config.enabled) {
      logger.warn("Tasksは無効です。");
      return "";
    }

    // タスクIDを生成
    const tasks = await this.loadTasks();
    const taskId = this.generateTaskId(tasks);

    const now = new Date().toISOString();
    const task: Task = {
      id: taskId,
      title,
      priority,
      status: "open",
      blocked_by: blockedBy,
      created_at: now,
      updated_at: now,
    };

    // JSONL形式で追記
    await this.appendTask(task);
    logger.info(`Task追加: ${taskId} - ${title}`);

    return taskId;
  }

  /**
   * ブロックされていないTaskを取得
   * @returns ready状態のTask配列
   */
  async getReadyTasks(): Promise<Task[]> {
    const tasks = await this.loadTasks();
    return tasks.filter(
      (task) => task.status === "open" && !this.isBlocked(task, tasks)
    );
  }

  /**
   * Task状態を更新
   * @param taskId - タスクID
   * @param status - 新しい状態
   */
  async updateStatus(taskId: string, status: TaskStatus): Promise<void> {
    const tasks = await this.loadTasks();
    const task = tasks.find((t) => t.id === taskId);

    if (!task) {
      logger.warn(`Task ${taskId} が見つかりません`);
      return;
    }

    const updatedTask: Task = {
      ...task,
      status,
      updated_at: new Date().toISOString(),
    };

    await this.appendTask(updatedTask);
    logger.info(`Task状態更新: ${taskId} -> ${status}`);
  }

  /**
   * すべてのTasksを取得（一覧表示用）
   * @returns Task配列
   */
  async listTasks(): Promise<Task[]> {
    return this.loadTasks();
  }

  /**
   * Taskを削除（状態を"closed"に更新）
   * @param taskId - タスクID
   */
  async deleteTask(taskId: string): Promise<void> {
    await this.updateStatus(taskId, "closed");
  }

  /**
   * すべてのTaskが完了しているか確認
   * @returns すべて完了している場合はtrue
   */
  async isAllTasksCompleted(): Promise<boolean> {
    const tasks = await this.loadTasks();
    return tasks.every((task) => task.status === "closed");
  }

  /**
   * JSONLをパース（最新状態のみ抽出）
   * @param content - JSONL内容
   * @returns Task配列
   */
  private parseTasks(content: string): Task[] {
    const lines = content.trim().split("\n").filter((line) => line);
    const taskMap = new Map<string, Task>();

    for (const line of lines) {
      try {
        const task = JSON.parse(line) as Task;
        // 同じIDの最新の行で上書き
        taskMap.set(task.id, task);
      } catch (error) {
        logger.warn(`不正なJSONL行をスキップ: ${line}`);
      }
    }

    // 優先度順にソート（1が最高）
    return Array.from(taskMap.values()).sort((a, b) => a.priority - b.priority);
  }

  /**
   * Taskを追記
   * @param task - Task
   */
  private async appendTask(task: Task): Promise<void> {
    const line = JSON.stringify(task) + "\n";
    await fs.appendFile(this.tasksPath, line);
  }

  /**
   * タスクIDを生成
   * @param tasks - 既存Task配列
   * @returns 新しいタスクID
   */
  private generateTaskId(tasks: Task[]): string {
    // 既存のタスクIDから最大番号を取得
    let maxNum = 0;
    for (const task of tasks) {
      const match = task.id.match(/^task-(\d+)$/);
      if (match) {
        const num = parseInt(match[1], 10);
        if (num > maxNum) {
          maxNum = num;
        }
      }
    }

    const nextNum = maxNum + 1;
    return `task-${String(nextNum).padStart(3, "0")}`;
  }

  /**
   * タスクがブロックされているか判定
   * @param task - Task
   * @param allTasks - すべてのTask配列
   * @returns ブロックされている場合はtrue
   */
  private isBlocked(task: Task, allTasks: Task[]): boolean {
    if (task.blocked_by.length === 0) {
      return false;
    }

    // 依存タスクがすべて完了しているか確認
    for (const depId of task.blocked_by) {
      const depTask = allTasks.find((t) => t.id === depId);
      if (!depTask) {
        logger.warn(`依存タスク ${depId} が存在しません。依存関係を無視します。`);
        continue;
      }
      if (depTask.status !== "closed") {
        return true; // 依存タスクが未完了
      }
    }

    return false; // すべての依存タスクが完了
  }
}
```

---

## 4. 型定義追加

### ファイル: `src/core/types.ts`（追加分）

```typescript
/**
 * Tasks設定のzodスキーマ
 */
export const TasksConfigSchema = z.object({
  /**
   * Tasksを有効にするか
   */
  enabled: z.boolean().default(true),
});

export type TasksConfig = z.infer<typeof TasksConfigSchema>;

// ConfigSchema に追加
export const ConfigSchema = z.object({
  // ... 既存フィールド

  // 新規: Tasks設定
  tasks: TasksConfigSchema.optional(),
});
```

---

## 5. CLI統合

### ファイル: `src/cli.ts`（追加分）

```typescript
import { TaskManager } from "./core/task-manager.js";

program
  .command("tools")
  .description("開発ツール")
  .command("task")
  .description("Task管理")
  .command("add <title>")
  .option("-p, --priority <priority>", "優先度（1-5）", "3")
  .option("--blocked-by <id>", "依存タスクID")
  .action(async (title, options) => {
    const config = await loadConfig();
    const manager = new TaskManager(config.tasks ?? { enabled: true }, ".agent");
    
    const blockedBy = options.blockedBy ? [options.blockedBy] : [];
    const taskId = await manager.addTask(title, Number(options.priority), blockedBy);
    logger.success(`Task追加完了: ${taskId}`);
  });

program
  .command("tools")
  .command("task")
  .command("list")
  .action(async () => {
    const config = await loadConfig();
    const manager = new TaskManager(config.tasks ?? { enabled: true }, ".agent");
    
    const tasks = await manager.listTasks();
    console.table(tasks);
  });

program
  .command("tools")
  .command("task")
  .command("ready")
  .action(async () => {
    const config = await loadConfig();
    const manager = new TaskManager(config.tasks ?? { enabled: true }, ".agent");
    
    const ready = await manager.getReadyTasks();
    console.table(ready);
  });

program
  .command("tools")
  .command("task")
  .command("close <id>")
  .action(async (id) => {
    const config = await loadConfig();
    const manager = new TaskManager(config.tasks ?? { enabled: true }, ".agent");
    
    await manager.updateStatus(id, "closed");
    logger.success("Task完了");
  });
```

---

## 6. Loop Engine統合

### ファイル: `src/core/loop.ts`（変更分）

```typescript
import { TaskManager } from "./task-manager.js";

export async function runLoop(context: LoopContext): Promise<LoopResult> {
  const taskManager = new TaskManager(
    context.config.tasks ?? { enabled: true },
    ".agent"
  );
  
  // Tasksを読み込み
  const tasks = await taskManager.loadTasks();
  logger.info(`Tasks読み込み: ${tasks.length}件`);
  
  // ループ完了検証
  if (await taskManager.isAllTasksCompleted()) {
    logger.success("すべてのタスクが完了しました");
    return { success: true, reason: "all_tasks_completed" };
  }
  
  // readyタスクを取得
  const readyTasks = await taskManager.getReadyTasks();
  
  if (readyTasks.length === 0) {
    logger.warn("実行可能なタスクがありません");
    return { success: false, reason: "no_ready_tasks" };
  }
  
  // 最優先タスクを実行
  const task = readyTasks[0];
  logger.info(`実行中のタスク: ${task.id} - ${task.title}`);
  
  await taskManager.updateStatus(task.id, "in-progress");
  
  // Hat実行
  const result = await executeHat(hat, {
    ...context,
    currentTask: task,
  });
  
  // タスク完了
  if (result.success) {
    await taskManager.updateStatus(task.id, "closed");
  }
  
  return result;
}
```

---

## 7. テスト設計

### 7.1 単体テスト

#### ファイル: `src/core/task-manager.test.ts`

```typescript
import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { TaskManager } from "./task-manager.js";
import * as fs from "fs/promises";
import * as path from "path";

const testDir = ".test-agent";
const tasksPath = path.join(testDir, "tasks.jsonl");

beforeEach(async () => {
  await fs.mkdir(testDir, { recursive: true });
});

afterEach(async () => {
  await fs.rm(testDir, { recursive: true, force: true });
});

describe("TaskManager", () => {
  test("Taskを追加", async () => {
    const manager = new TaskManager({ enabled: true }, testDir);

    const taskId = await manager.addTask("Add auth", 2);

    expect(taskId).toBe("task-001");

    const tasks = await manager.listTasks();
    expect(tasks).toHaveLength(1);
    expect(tasks[0].title).toBe("Add auth");
    expect(tasks[0].priority).toBe(2);
  });

  test("Task状態を更新", async () => {
    const manager = new TaskManager({ enabled: true }, testDir);

    const taskId = await manager.addTask("Task 1", 1);
    await manager.updateStatus(taskId, "in-progress");
    await manager.updateStatus(taskId, "closed");

    const tasks = await manager.listTasks();
    expect(tasks[0].status).toBe("closed");
  });

  test("ブロックされていないTaskを取得", async () => {
    const manager = new TaskManager({ enabled: true }, testDir);

    const task1 = await manager.addTask("Task 1", 1);
    await manager.addTask("Task 2", 2, [task1]);

    const ready = await manager.getReadyTasks();
    expect(ready).toHaveLength(1);
    expect(ready[0].id).toBe(task1);
  });

  test("依存タスクが完了したらブロック解除", async () => {
    const manager = new TaskManager({ enabled: true }, testDir);

    const task1 = await manager.addTask("Task 1", 1);
    await manager.addTask("Task 2", 2, [task1]);

    let ready = await manager.getReadyTasks();
    expect(ready).toHaveLength(1);

    // Task 1を完了
    await manager.updateStatus(task1, "closed");

    ready = await manager.getReadyTasks();
    expect(ready).toHaveLength(1);
    expect(ready[0].id).toBe("task-002");
  });

  test("すべてのTaskが完了しているか確認", async () => {
    const manager = new TaskManager({ enabled: true }, testDir);

    const task1 = await manager.addTask("Task 1", 1);
    const task2 = await manager.addTask("Task 2", 2);

    expect(await manager.isAllTasksCompleted()).toBe(false);

    await manager.updateStatus(task1, "closed");
    expect(await manager.isAllTasksCompleted()).toBe(false);

    await manager.updateStatus(task2, "closed");
    expect(await manager.isAllTasksCompleted()).toBe(true);
  });

  test("優先度順にソート", async () => {
    const manager = new TaskManager({ enabled: true }, testDir);

    await manager.addTask("Low priority", 5);
    await manager.addTask("High priority", 1);
    await manager.addTask("Medium priority", 3);

    const tasks = await manager.listTasks();
    expect(tasks[0].priority).toBe(1);
    expect(tasks[1].priority).toBe(3);
    expect(tasks[2].priority).toBe(5);
  });
});
```

---

## 8. 実装メモ

### 8.1 JSONL形式

追記型のログ形式。各行が独立したJSONオブジェクト。

### 8.2 状態更新

状態更新は新しい行を追記。最新の状態は同じIDの最後の行。

### 8.3 タスクID

`task-001`, `task-002`, ... の形式で自動生成。

---

## 9. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
