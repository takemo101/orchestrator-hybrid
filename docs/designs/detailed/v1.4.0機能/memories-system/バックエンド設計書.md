# Memories System バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-004-F014-BE |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-004-F014 |
| 対象機能 | F-014 |

---

## 1. 概要

Memories System機能のバックエンド実装仕様を定義します。

---

## 2. ファイル構成

| ファイル | 説明 | 新規/変更 |
|---------|------|----------|
| `src/core/memory-manager.ts` | MemoryManagerクラス | 新規 |
| `src/core/memory-manager.test.ts` | 単体テスト | 新規 |
| `src/core/types.ts` | MemoriesConfigSchema追加 | 変更 |
| `src/cli.ts` | `orch tools memory`コマンド追加 | 変更 |
| `src/core/loop.ts` | MemoryManager統合 | 変更 |
| `src/core/worktree-manager.ts` | シンボリックリンク作成 | 変更 |

---

## 3. クラス詳細設計

### 3.1 MemoryManager

#### ファイル: `src/core/memory-manager.ts`

```typescript
import * as fs from "fs/promises";
import * as path from "path";
import { logger } from "./logger.js";

/**
 * Memory
 */
export interface Memory {
  id: number;
  title: string;
  tags: string[];
  date: string;
  content: string;
}

/**
 * Memories設定
 */
export interface MemoriesConfig {
  enabled: boolean;
  inject: "auto" | "manual" | "none";
}

/**
 * Memory管理クラス
 * 
 * @example
 * ```typescript
 * const manager = new MemoryManager(
 *   { enabled: true, inject: "auto" },
 *   ".agent"
 * );
 * 
 * // Memoryを追加
 * await manager.addMemory("Always use try-catch", ["pattern", "error-handling"]);
 * 
 * // Memoryを検索
 * const results = await manager.searchMemories("error");
 * ```
 */
export class MemoryManager {
  private readonly config: MemoriesConfig;
  private readonly memoriesPath: string;
  private readonly maxSizeBytes = 10 * 1024 * 1024; // 10MB

  constructor(config: MemoriesConfig, baseDir: string) {
    this.config = config;
    this.memoriesPath = path.join(baseDir, "memories.md");
  }

  /**
   * Memoriesを読み込み
   * @returns Memory配列
   */
  async loadMemories(): Promise<Memory[]> {
    if (!this.config.enabled) {
      return [];
    }

    try {
      const content = await fs.readFile(this.memoriesPath, "utf-8");
      return this.parseMemories(content);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === "ENOENT") {
        // ファイルが存在しない場合は空配列
        return [];
      }
      
      logger.warn(
        `memories.mdの読み込みに失敗しました。空のmemoriesとして扱います。`,
        error
      );
      return [];
    }
  }

  /**
   * Memoryを追加
   * @param content - 学習内容
   * @param tags - タグ（オプション）
   */
  async addMemory(content: string, tags: string[] = []): Promise<void> {
    if (!this.config.enabled) {
      logger.warn("Memoriesは無効です。");
      return;
    }

    // サイズチェック
    await this.checkSize();

    const date = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
    const title = this.generateTitle(content);

    const entry = [
      `## ${title}`,
      `- Tags: ${tags.join(", ")}`,
      `- Date: ${date}`,
      `- Content: ${content}`,
      "",
    ].join("\n");

    // ファイルが存在しない場合は作成
    try {
      await fs.access(this.memoriesPath);
    } catch {
      await fs.writeFile(this.memoriesPath, "# Memories\n\n");
    }

    // 追記
    await fs.appendFile(this.memoriesPath, entry);
    logger.info(`Memory追加: ${title}`);
  }

  /**
   * Memoryを検索
   * @param query - 検索クエリ
   * @returns マッチしたMemory配列
   */
  async searchMemories(query: string): Promise<Memory[]> {
    const memories = await this.loadMemories();
    const lowerQuery = query.toLowerCase();

    return memories.filter(
      (memory) =>
        memory.title.toLowerCase().includes(lowerQuery) ||
        memory.content.toLowerCase().includes(lowerQuery) ||
        memory.tags.some((tag) => tag.toLowerCase().includes(lowerQuery))
    );
  }

  /**
   * Memoryを削除
   * @param id - MemoryのID（見出し行番号）
   */
  async deleteMemory(id: number): Promise<void> {
    const memories = await this.loadMemories();
    const filtered = memories.filter((m) => m.id !== id);

    // 再構築
    const content = this.buildMemoriesContent(filtered);
    await fs.writeFile(this.memoriesPath, content);
    logger.info(`Memory削除: ID=${id}`);
  }

  /**
   * すべてのMemoriesを取得（一覧表示用）
   * @returns Memory配列
   */
  async listMemories(): Promise<Memory[]> {
    return this.loadMemories();
  }

  /**
   * Memoriesをプロンプトに注入するための文字列を生成
   * @returns 注入用文字列
   */
  async getInjectionContent(): Promise<string> {
    if (this.config.inject !== "auto") {
      return "";
    }

    const memories = await this.loadMemories();
    if (memories.length === 0) {
      return "";
    }

    const lines = ["# Memories", ""];
    for (const memory of memories) {
      lines.push(`## ${memory.title}`);
      lines.push(`- Tags: ${memory.tags.join(", ")}`);
      lines.push(`- Date: ${memory.date}`);
      lines.push(`- Content: ${memory.content}`);
      lines.push("");
    }
    lines.push("---", "");

    return lines.join("\n");
  }

  /**
   * Markdownをパース
   * @param content - Markdown内容
   * @returns Memory配列
   */
  private parseMemories(content: string): Memory[] {
    const lines = content.split("\n");
    const memories: Memory[] = [];
    let currentMemory: Partial<Memory> | null = null;
    let lineNumber = 0;

    for (const line of lines) {
      lineNumber++;

      if (line.startsWith("## ")) {
        // 前のMemoryを保存
        if (currentMemory && currentMemory.title) {
          memories.push(currentMemory as Memory);
        }

        // 新しいMemory開始
        currentMemory = {
          id: lineNumber,
          title: line.substring(3).trim(),
          tags: [],
          date: "",
          content: "",
        };
      } else if (line.startsWith("- Tags:") && currentMemory) {
        const tagsStr = line.substring(7).trim();
        currentMemory.tags = tagsStr.split(",").map((t) => t.trim());
      } else if (line.startsWith("- Date:") && currentMemory) {
        currentMemory.date = line.substring(7).trim();
      } else if (line.startsWith("- Content:") && currentMemory) {
        currentMemory.content = line.substring(10).trim();
      }
    }

    // 最後のMemoryを保存
    if (currentMemory && currentMemory.title) {
      memories.push(currentMemory as Memory);
    }

    return memories;
  }

  /**
   * Memory配列からMarkdown内容を構築
   * @param memories - Memory配列
   * @returns Markdown内容
   */
  private buildMemoriesContent(memories: Memory[]): string {
    const lines = ["# Memories", ""];
    for (const memory of memories) {
      lines.push(`## ${memory.title}`);
      lines.push(`- Tags: ${memory.tags.join(", ")}`);
      lines.push(`- Date: ${memory.date}`);
      lines.push(`- Content: ${memory.content}`);
      lines.push("");
    }
    return lines.join("\n");
  }

  /**
   * タイトルを生成（内容の最初の50文字）
   * @param content - 内容
   * @returns タイトル
   */
  private generateTitle(content: string): string {
    const maxLength = 50;
    if (content.length <= maxLength) {
      return content;
    }
    return content.substring(0, maxLength) + "...";
  }

  /**
   * ファイルサイズをチェック
   * @throws Error - サイズ上限超過時
   */
  private async checkSize(): Promise<void> {
    try {
      const stats = await fs.stat(this.memoriesPath);
      if (stats.size > this.maxSizeBytes) {
        logger.warn(
          `memories.mdのサイズが上限（10MB）を超えました。古いエントリを削除してください。`
        );
      }
    } catch {
      // ファイルが存在しない場合は無視
    }
  }
}
```

---

## 4. 型定義追加

### ファイル: `src/core/types.ts`（追加分）

```typescript
/**
 * Memories設定のzodスキーマ
 */
export const MemoriesConfigSchema = z.object({
  /**
   * Memoriesを有効にするか
   */
  enabled: z.boolean().default(true),

  /**
   * プロンプトへの注入モード
   */
  inject: z.enum(["auto", "manual", "none"]).default("auto"),
});

export type MemoriesConfig = z.infer<typeof MemoriesConfigSchema>;

// ConfigSchema に追加
export const ConfigSchema = z.object({
  // ... 既存フィールド

  // 新規: Memories設定
  memories: MemoriesConfigSchema.optional(),
});
```

---

## 5. CLI統合

### ファイル: `src/cli.ts`（追加分）

```typescript
import { MemoryManager } from "./core/memory-manager.js";

program
  .command("tools")
  .description("開発ツール")
  .command("memory")
  .description("Memory管理")
  .command("add <content>")
  .option("-t, --type <type>", "Memoryタイプ（pattern/architecture/solution）")
  .option("--tags <tags>", "タグ（カンマ区切り）")
  .action(async (content, options) => {
    const config = await loadConfig();
    const manager = new MemoryManager(config.memories ?? { enabled: true, inject: "auto" }, ".agent");
    
    const tags = options.tags ? options.tags.split(",") : [];
    if (options.type) {
      tags.unshift(options.type);
    }
    
    await manager.addMemory(content, tags);
    logger.success("Memory追加完了");
  });

program
  .command("tools")
  .command("memory")
  .command("search <query>")
  .action(async (query) => {
    const config = await loadConfig();
    const manager = new MemoryManager(config.memories ?? { enabled: true, inject: "auto" }, ".agent");
    
    const results = await manager.searchMemories(query);
    console.table(results);
  });

program
  .command("tools")
  .command("memory")
  .command("list")
  .action(async () => {
    const config = await loadConfig();
    const manager = new MemoryManager(config.memories ?? { enabled: true, inject: "auto" }, ".agent");
    
    const memories = await manager.listMemories();
    console.table(memories);
  });

program
  .command("tools")
  .command("memory")
  .command("delete <id>")
  .action(async (id) => {
    const config = await loadConfig();
    const manager = new MemoryManager(config.memories ?? { enabled: true, inject: "auto" }, ".agent");
    
    await manager.deleteMemory(Number(id));
    logger.success("Memory削除完了");
  });
```

---

## 6. Loop Engine統合

### ファイル: `src/core/loop.ts`（変更分）

```typescript
import { MemoryManager } from "./memory-manager.js";

export async function runLoop(context: LoopContext): Promise<LoopResult> {
  const memoryManager = new MemoryManager(
    context.config.memories ?? { enabled: true, inject: "auto" },
    ".agent"
  );
  
  // Memoriesを読み込み
  const memories = await memoryManager.loadMemories();
  logger.info(`Memories読み込み: ${memories.length}件`);
  
  // プロンプト注入（inject: auto時）
  const injectionContent = await memoryManager.getInjectionContent();
  const prompt = injectionContent + context.prompt;
  
  // Hat実行
  const result = await executeHat(hat, {
    ...context,
    prompt,
  });
  
  // 新しい学習内容を抽出してMemoryに追加
  // （実装は別途検討）
  
  return result;
}
```

---

## 7. Worktree統合

### ファイル: `src/core/worktree-manager.ts`（変更分）

```typescript
async createWorktree(loopId: string): Promise<string> {
  // ... worktree作成処理

  // .agentディレクトリ作成
  const agentDir = path.join(worktreePath, ".agent");
  await fs.mkdir(agentDir, { recursive: true });

  // memories.mdをシンボリックリンク
  const memoriesPath = path.join(agentDir, "memories.md");
  const primaryMemoriesPath = path.join(this.baseDir, ".agent", "memories.md");
  
  try {
    await fs.symlink(primaryMemoriesPath, memoriesPath);
    logger.info(`Memoriesをシンボリックリンク: ${memoriesPath}`);
  } catch (error) {
    logger.warn(`Memoriesのシンボリックリンク作成に失敗:`, error);
  }

  return worktreePath;
}
```

---

## 8. テスト設計

### 8.1 単体テスト

#### ファイル: `src/core/memory-manager.test.ts`

```typescript
import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { MemoryManager } from "./memory-manager.js";
import * as fs from "fs/promises";
import * as path from "path";

const testDir = ".test-agent";
const memoriesPath = path.join(testDir, "memories.md");

beforeEach(async () => {
  await fs.mkdir(testDir, { recursive: true });
});

afterEach(async () => {
  await fs.rm(testDir, { recursive: true, force: true });
});

describe("MemoryManager", () => {
  test("Memoryを追加", async () => {
    const manager = new MemoryManager(
      { enabled: true, inject: "auto" },
      testDir
    );

    await manager.addMemory("Always use try-catch", ["pattern", "error-handling"]);

    const content = await fs.readFile(memoriesPath, "utf-8");
    expect(content).toContain("Always use try-catch");
    expect(content).toContain("pattern, error-handling");
  });

  test("Memoryを検索", async () => {
    const manager = new MemoryManager(
      { enabled: true, inject: "auto" },
      testDir
    );

    await manager.addMemory("Always use try-catch", ["pattern"]);
    await manager.addMemory("Use PostgreSQL", ["database"]);

    const results = await manager.searchMemories("try-catch");
    expect(results).toHaveLength(1);
    expect(results[0].content).toBe("Always use try-catch");
  });

  test("Memoryを削除", async () => {
    const manager = new MemoryManager(
      { enabled: true, inject: "auto" },
      testDir
    );

    await manager.addMemory("Memory 1", []);
    await manager.addMemory("Memory 2", []);

    const memories = await manager.listMemories();
    expect(memories).toHaveLength(2);

    await manager.deleteMemory(memories[0].id);

    const updated = await manager.listMemories();
    expect(updated).toHaveLength(1);
  });

  test("inject: auto でプロンプトに注入", async () => {
    const manager = new MemoryManager(
      { enabled: true, inject: "auto" },
      testDir
    );

    await manager.addMemory("Always use try-catch", ["pattern"]);

    const injection = await manager.getInjectionContent();
    expect(injection).toContain("# Memories");
    expect(injection).toContain("Always use try-catch");
  });

  test("inject: manual でプロンプトに注入しない", async () => {
    const manager = new MemoryManager(
      { enabled: true, inject: "manual" },
      testDir
    );

    await manager.addMemory("Always use try-catch", ["pattern"]);

    const injection = await manager.getInjectionContent();
    expect(injection).toBe("");
  });
});
```

---

## 9. 実装メモ

### 9.1 Markdown形式

シンプルなMarkdown形式を採用。見出し（`##`）でMemoryを区切る。

### 9.2 サイズ上限

10MBを上限とし、超過時は警告ログを出力。

### 9.3 シンボリックリンク

Worktree間でmemoriesを共有するため、シンボリックリンクを使用。

---

## 10. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
