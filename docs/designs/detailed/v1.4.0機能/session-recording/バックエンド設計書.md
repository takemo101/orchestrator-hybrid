# Session Recording バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-004-F016-BE |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-004-F016 |
| 対象機能 | F-016 |

---

## 1. 概要

Session Recording機能のバックエンド実装仕様を定義します。

---

## 2. ファイル構成

| ファイル | 説明 | 新規/変更 |
|---------|------|----------|
| `src/core/session-recorder.ts` | SessionRecorderクラス | 新規 |
| `src/core/session-replayer.ts` | SessionReplayerクラス | 新規 |
| `src/core/session-recorder.test.ts` | 単体テスト | 新規 |
| `src/core/session-replayer.test.ts` | 単体テスト | 新規 |
| `src/cli.ts` | `--record-session`オプション、`replay`コマンド追加 | 変更 |
| `src/core/loop.ts` | SessionRecorder統合 | 変更 |

---

## 3. クラス詳細設計

### 3.1 SessionRecorder

#### ファイル: `src/core/session-recorder.ts`

```typescript
import * as fs from "fs/promises";
import { logger } from "./logger.js";

/**
 * Session記録
 */
export interface SessionRecord {
  iteration: number;
  hat: string;
  prompt: string;
  output: string;
  events: string[];
  timestamp: string;
}

/**
 * Session記録クラス
 * 
 * @example
 * ```typescript
 * const recorder = new SessionRecorder("session.jsonl");
 * await recorder.startRecording();
 * 
 * await recorder.recordIteration(1, "planner", "...", "...", ["plan.ready"]);
 * await recorder.recordIteration(2, "implementer", "...", "...", ["code.written"]);
 * 
 * await recorder.stopRecording();
 * ```
 */
export class SessionRecorder {
  private readonly filePath: string;
  private readonly maxSizeBytes = 100 * 1024 * 1024; // 100MB
  private isRecording = false;

  constructor(filePath: string) {
    this.filePath = filePath;
  }

  /**
   * 記録を開始
   */
  async startRecording(): Promise<void> {
    try {
      // ファイルが存在する場合は削除
      await fs.unlink(this.filePath).catch(() => {});
      
      // 空ファイルを作成
      await fs.writeFile(this.filePath, "");
      
      this.isRecording = true;
      logger.info(`セッション記録開始: ${this.filePath}`);
    } catch (error) {
      logger.error(`セッション記録の開始に失敗しました:`, error);
      throw error;
    }
  }

  /**
   * イテレーションを記録
   * @param iteration - イテレーション番号
   * @param hat - Hat名
   * @param prompt - プロンプト
   * @param output - 出力
   * @param events - 発行されたイベント
   */
  async recordIteration(
    iteration: number,
    hat: string,
    prompt: string,
    output: string,
    events: string[]
  ): Promise<void> {
    if (!this.isRecording) {
      logger.warn("セッション記録が開始されていません");
      return;
    }

    try {
      // サイズチェック
      await this.checkSize();

      const record: SessionRecord = {
        iteration,
        hat,
        prompt,
        output,
        events,
        timestamp: new Date().toISOString(),
      };

      const line = JSON.stringify(record) + "\n";
      await fs.appendFile(this.filePath, line);
      
      logger.debug(`イテレーション ${iteration} を記録`);
    } catch (error) {
      logger.error(
        `セッション記録の書き込みに失敗しました。記録をスキップして実行継続します。`,
        error
      );
    }
  }

  /**
   * 記録を停止
   */
  async stopRecording(): Promise<void> {
    this.isRecording = false;
    logger.info(`セッション記録完了: ${this.filePath}`);
  }

  /**
   * ファイルサイズをチェック
   * @throws Error - サイズ上限超過時
   */
  private async checkSize(): Promise<void> {
    try {
      const stats = await fs.stat(this.filePath);
      if (stats.size > this.maxSizeBytes) {
        logger.warn(
          `セッション記録のサイズが上限（100MB）を超えました。記録を停止します。`
        );
        this.isRecording = false;
      }
    } catch {
      // ファイルが存在しない場合は無視
    }
  }
}
```

---

### 3.2 SessionReplayer

#### ファイル: `src/core/session-replayer.ts`

```typescript
import * as fs from "fs/promises";
import { logger } from "./logger.js";
import type { SessionRecord } from "./session-recorder.js";

/**
 * リプレイ結果
 */
export interface ReplayResult {
  success: boolean;
  iterations: number;
  errors: string[];
}

/**
 * Sessionリプレイクラス
 * 
 * @example
 * ```typescript
 * const replayer = new SessionReplayer("session.jsonl");
 * const result = await replayer.replay();
 * 
 * if (result.success) {
 *   console.log(`リプレイ完了: ${result.iterations}イテレーション`);
 * }
 * ```
 */
export class SessionReplayer {
  private readonly filePath: string;

  constructor(filePath: string) {
    this.filePath = filePath;
  }

  /**
   * セッションをリプレイ
   * @returns リプレイ結果
   */
  async replay(): Promise<ReplayResult> {
    const errors: string[] = [];
    
    try {
      const records = await this.loadRecords();
      logger.info(`セッションリプレイ開始: ${records.length}イテレーション`);
      
      for (const record of records) {
        try {
          await this.replayIteration(record);
        } catch (error) {
          const errorMsg = `イテレーション ${record.iteration} のリプレイに失敗: ${error}`;
          logger.error(errorMsg);
          errors.push(errorMsg);
        }
      }
      
      const success = errors.length === 0;
      logger.info(`セッションリプレイ完了: ${success ? "成功" : "失敗"}`);
      
      return {
        success,
        iterations: records.length,
        errors,
      };
    } catch (error) {
      logger.error(`セッションリプレイに失敗:`, error);
      return {
        success: false,
        iterations: 0,
        errors: [String(error)],
      };
    }
  }

  /**
   * 記録を読み込み
   * @returns SessionRecord配列
   */
  private async loadRecords(): Promise<SessionRecord[]> {
    try {
      const content = await fs.readFile(this.filePath, "utf-8");
      const lines = content.trim().split("\n").filter((line) => line);
      
      return lines.map((line) => JSON.parse(line) as SessionRecord);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === "ENOENT") {
        throw new Error(`セッション記録ファイルが見つかりません: ${this.filePath}`);
      }
      throw error;
    }
  }

  /**
   * イテレーションをリプレイ
   * @param record - SessionRecord
   */
  private async replayIteration(record: SessionRecord): Promise<void> {
    logger.info(
      `Replaying iteration ${record.iteration}: ${record.hat}`
    );
    
    // 記録された出力を表示
    logger.info(`Output:\n${record.output}`);
    
    // イベントを表示
    if (record.events.length > 0) {
      logger.info(`Events: ${record.events.join(", ")}`);
    }
    
    // 検証（オプション）
    // - 出力が期待通りか
    // - イベントが期待通りか
  }
}
```

---

## 4. CLI統合

### ファイル: `src/cli.ts`（変更分）

```typescript
import { SessionRecorder } from "./core/session-recorder.js";
import { SessionReplayer } from "./core/session-replayer.js";

program
  .command("run")
  // ... 既存オプション
  .option("--record-session <file>", "セッションを記録")
  .action(async (options) => {
    // ... 既存処理

    // SessionRecorder初期化
    let recorder: SessionRecorder | undefined;
    if (options.recordSession) {
      recorder = new SessionRecorder(options.recordSession);
      await recorder.startRecording();
    }

    // LoopContextに渡す
    const context: LoopContext = {
      // ... 既存フィールド
      sessionRecorder: recorder, // 追加
    };

    // ... 既存処理
  });

program
  .command("replay <file>")
  .description("セッションをリプレイ")
  .action(async (file) => {
    const replayer = new SessionReplayer(file);
    const result = await replayer.replay();
    
    if (result.success) {
      logger.success(`リプレイ完了: ${result.iterations}イテレーション`);
    } else {
      logger.error(`リプレイ失敗: ${result.errors.length}エラー`);
      for (const error of result.errors) {
        logger.error(error);
      }
      process.exit(1);
    }
  });
```

---

## 5. Loop Engine統合

### ファイル: `src/core/loop.ts`（変更分）

```typescript
import type { SessionRecorder } from "./session-recorder.js";

export interface LoopContext {
  // ... 既存フィールド

  /**
   * セッション記録器（オプション）
   */
  sessionRecorder?: SessionRecorder;
}

export async function runLoop(context: LoopContext): Promise<LoopResult> {
  // ... 既存処理

  // イテレーション実行
  for (let i = 0; i < maxIterations; i++) {
    const iteration = i + 1;
    
    // Hat実行
    const result = await executeHat(hat, context);
    
    // セッション記録
    if (context.sessionRecorder) {
      await context.sessionRecorder.recordIteration(
        iteration,
        hat.name,
        prompt,
        result.output,
        result.events
      );
    }
    
    // ... 既存処理
  }

  // セッション記録停止
  if (context.sessionRecorder) {
    await context.sessionRecorder.stopRecording();
  }

  return result;
}
```

---

## 6. テスト設計

### 6.1 単体テスト

#### ファイル: `src/core/session-recorder.test.ts`

```typescript
import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { SessionRecorder } from "./session-recorder.js";
import * as fs from "fs/promises";

const testFile = ".test-session.jsonl";

beforeEach(async () => {
  await fs.unlink(testFile).catch(() => {});
});

afterEach(async () => {
  await fs.unlink(testFile).catch(() => {});
});

describe("SessionRecorder", () => {
  test("セッションを記録", async () => {
    const recorder = new SessionRecorder(testFile);
    await recorder.startRecording();

    await recorder.recordIteration(1, "planner", "prompt1", "output1", ["plan.ready"]);
    await recorder.recordIteration(2, "implementer", "prompt2", "output2", ["code.written"]);

    await recorder.stopRecording();

    const content = await fs.readFile(testFile, "utf-8");
    const lines = content.trim().split("\n");
    
    expect(lines).toHaveLength(2);
    
    const record1 = JSON.parse(lines[0]);
    expect(record1.iteration).toBe(1);
    expect(record1.hat).toBe("planner");
    expect(record1.events).toEqual(["plan.ready"]);
  });
});
```

#### ファイル: `src/core/session-replayer.test.ts`

```typescript
import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { SessionReplayer } from "./session-replayer.js";
import { SessionRecorder } from "./session-recorder.js";
import * as fs from "fs/promises";

const testFile = ".test-session.jsonl";

beforeEach(async () => {
  await fs.unlink(testFile).catch(() => {});
});

afterEach(async () => {
  await fs.unlink(testFile).catch(() => {});
});

describe("SessionReplayer", () => {
  test("セッションをリプレイ", async () => {
    // 記録
    const recorder = new SessionRecorder(testFile);
    await recorder.startRecording();
    await recorder.recordIteration(1, "planner", "prompt1", "output1", ["plan.ready"]);
    await recorder.recordIteration(2, "implementer", "prompt2", "output2", ["code.written"]);
    await recorder.stopRecording();

    // リプレイ
    const replayer = new SessionReplayer(testFile);
    const result = await replayer.replay();

    expect(result.success).toBe(true);
    expect(result.iterations).toBe(2);
    expect(result.errors).toHaveLength(0);
  });

  test("ファイルが存在しない場合はエラー", async () => {
    const replayer = new SessionReplayer("non-existent.jsonl");
    const result = await replayer.replay();

    expect(result.success).toBe(false);
    expect(result.errors).toHaveLength(1);
  });
});
```

---

## 7. 実装メモ

### 7.1 JSONL形式

追記型のログ形式。各行が独立したJSONオブジェクト。

### 7.2 サイズ上限

100MBを上限とし、超過時は記録を停止。

### 7.3 リプレイ

APIコールせずに記録された出力を使用。Smoke testとして活用。

---

## 8. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
