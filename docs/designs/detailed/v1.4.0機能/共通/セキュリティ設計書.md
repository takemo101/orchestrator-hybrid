# v1.4.0機能 セキュリティ設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-004-COMMON-SECURITY |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-26 |
| 最終更新日 | 2026-01-26 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連基本設計書 | BASIC-ORCH-004 v1.0.0 |

---

## 1. 概要

v1.4.0で追加される機能（F-013〜F-021）に関するセキュリティ設計を定義します。

---

## 2. セキュリティ要件

### 2.1 基本設計書からの要件

| ID | 要件 | 詳細 |
|----|------|------|
| NFR-S-005 | GitHub Token管理 | 環境変数または設定ファイル（.gitignore対象） |
| NFR-S-006 | 機密情報のログ出力禁止 | トークン、パスワードはマスク |

### 2.2 v1.4.0追加セキュリティ要件

| ID | 要件 | 対象機能 |
|----|------|---------|
| SEC-010 | Memories内容のサニタイズ | F-014 |
| SEC-011 | Session Recording内の機密情報マスク | F-016 |
| SEC-012 | worktree間のファイルパーミッション分離 | F-017 |
| SEC-013 | カスタムバックエンドのコマンドインジェクション防止 | F-019 |
| SEC-014 | イベントペイロードのバリデーション | F-020 |

---

## 3. Memories セキュリティ（F-014）

### 3.1 リスク

Memoriesに機密情報（APIキー、パスワード等）が誤って記録される可能性があります。

### 3.2 対策

#### 3.2.1 保存前のサニタイズ

```typescript
// src/core/memory-manager.ts

const SENSITIVE_PATTERNS = [
  { pattern: /ghp_[a-zA-Z0-9]{36}/g, replacement: "[GH_TOKEN]" },
  { pattern: /gho_[a-zA-Z0-9]{36}/g, replacement: "[GH_TOKEN]" },
  { pattern: /github_pat_[a-zA-Z0-9_]{22,}/g, replacement: "[GH_PAT]" },
  { pattern: /sk-[a-zA-Z0-9]{48}/g, replacement: "[API_KEY]" },
  { pattern: /password\s*[=:]\s*\S+/gi, replacement: "password=[MASKED]" },
  { pattern: /token\s*[=:]\s*\S+/gi, replacement: "token=[MASKED]" },
  { pattern: /secret\s*[=:]\s*\S+/gi, replacement: "secret=[MASKED]" },
  { pattern: /api[_-]?key\s*[=:]\s*\S+/gi, replacement: "api_key=[MASKED]" },
];

export function sanitizeMemoryContent(content: string): string {
  let sanitized = content;
  for (const { pattern, replacement } of SENSITIVE_PATTERNS) {
    sanitized = sanitized.replace(pattern, replacement);
  }
  return sanitized;
}
```

#### 3.2.2 Memoriesファイルの保護

```bash
# Memoriesファイルの権限設定
chmod 600 .agent/memories.md
```

#### 3.2.3 .gitignoreへの追加

```gitignore
# Memoriesファイル（機密情報を含む可能性あり）
.agent/memories.md
```

### 3.3 worktree間でのMemories共有

Memoriesはシンボリックリンクで共有されるため、以下の点に注意：

- シンボリックリンク先のファイルパーミッションを確認
- 共有されたMemoriesが全worktreeで同じ権限を持つことを保証

```typescript
// worktree作成時のシンボリックリンク作成
async function linkMemories(worktreePath: string, primaryPath: string): Promise<void> {
  const targetPath = path.join(worktreePath, ".agent", "memories.md");
  const sourcePath = path.join(primaryPath, ".agent", "memories.md");
  
  // ディレクトリ作成
  await fs.mkdir(path.dirname(targetPath), { recursive: true });
  
  // シンボリックリンク作成（相対パス）
  const relativePath = path.relative(path.dirname(targetPath), sourcePath);
  await fs.symlink(relativePath, targetPath);
}
```

---

## 4. Session Recording セキュリティ（F-016）

### 4.1 リスク

セッション記録にAIエージェントの入出力が含まれるため、機密情報が記録される可能性があります。

### 4.2 対策

#### 4.2.1 記録前のマスク処理

```typescript
// src/core/session-recorder.ts

export function maskSessionEntry(entry: SessionRecordEntry): SessionRecordEntry {
  return {
    ...entry,
    prompt: maskSensitiveData(entry.prompt),
    output: maskSensitiveData(entry.output),
  };
}
```

#### 4.2.2 記録ファイルの保護

| ファイル | 権限 | 説明 |
|---------|------|------|
| `session.jsonl` | 600 | 所有者のみ読み書き可能 |

#### 4.2.3 .gitignoreへの追加

```gitignore
# セッション記録（機密情報を含む可能性あり）
*.session.jsonl
session-*.jsonl
```

### 4.3 リプレイ時のセキュリティ

リプレイ時は記録されたデータを使用するため、APIコールは発生しません。
ただし、記録ファイルが改ざんされている可能性を考慮し、以下を実装：

```typescript
// リプレイ前のファイル検証
export function validateSessionFile(path: string): boolean {
  // ファイルサイズの上限チェック
  const stats = fs.statSync(path);
  if (stats.size > 100 * 1024 * 1024) { // 100MB
    throw new SessionRecordError("セッション記録ファイルが大きすぎます");
  }
  
  // JSONL形式の検証
  const lines = fs.readFileSync(path, "utf-8").split("\n");
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].trim() === "") continue;
    try {
      JSON.parse(lines[i]);
    } catch {
      throw new SessionRecordError(`行 ${i + 1} のJSON形式が不正です`);
    }
  }
  
  return true;
}
```

---

## 5. Worktree セキュリティ（F-017）

### 5.1 リスク

複数のworktreeが同じリポジトリを共有するため、以下のリスクがあります：

- ファイルパーミッションの不整合
- 機密ファイルの意図しない共有
- プロセス間の干渉

### 5.2 対策

#### 5.2.1 worktree作成時のパーミッション設定

```typescript
// src/core/worktree-manager.ts

async function createWorktree(path: string, branch: string): Promise<void> {
  // worktree作成
  await exec("git", ["worktree", "add", "-b", branch, path]);
  
  // .agentディレクトリの権限設定
  const agentDir = join(path, ".agent");
  await fs.mkdir(agentDir, { recursive: true, mode: 0o700 });
}
```

#### 5.2.2 機密ファイルの分離

Memoriesのみシンボリックリンクで共有し、以下のファイルは各worktreeで独立：

| ファイル | 共有方式 | 理由 |
|---------|---------|------|
| `.agent/memories.md` | シンボリックリンク | 学習内容の共有 |
| `.agent/scratchpad.md` | 独立 | タスク固有の状態 |
| `.agent/tasks.jsonl` | 独立 | タスク固有の進捗 |
| `.agent/events.jsonl` | 独立 | ループ固有のイベント |

#### 5.2.3 プロセス分離

```typescript
// ループロックによる排他制御
const LOCK_FILE = ".orch/loop.lock";

async function acquireLock(): Promise<boolean> {
  try {
    // O_EXCL フラグで排他的にファイル作成
    const fd = fs.openSync(LOCK_FILE, fs.constants.O_CREAT | fs.constants.O_EXCL | fs.constants.O_WRONLY);
    fs.writeSync(fd, String(process.pid));
    fs.closeSync(fd);
    return true;
  } catch {
    return false; // 既にロックされている
  }
}

async function releaseLock(): Promise<void> {
  try {
    fs.unlinkSync(LOCK_FILE);
  } catch {
    // ファイルが存在しない場合は無視
  }
}
```

### 5.3 自動マージ時のセキュリティ

マージ失敗時に`needs-review`状態にして手動確認を促します。

```typescript
// 自動マージの安全性確保
async function safeAutoMerge(loopId: string): Promise<boolean> {
  try {
    // 差分の確認
    const diff = await exec("git", ["diff", "--stat", "main"]);
    
    // 差分が大きすぎる場合は警告
    if (countChangedFiles(diff) > 50) {
      logger.warn(`ループ ${loopId} の変更が大きいため、手動確認を推奨します`);
    }
    
    // マージ実行
    await exec("git", ["merge", "--no-edit", loopId]);
    return true;
  } catch (error) {
    // マージ失敗時は状態を更新
    await updateLoopState(loopId, "needs-review");
    return false;
  }
}
```

---

## 6. カスタムバックエンド セキュリティ（F-019）

### 6.1 リスク

カスタムバックエンドの設定により、任意のコマンドが実行される可能性があります。

### 6.2 対策

#### 6.2.1 コマンドのバリデーション

```typescript
// src/adapters/custom-backend.ts

const ALLOWED_COMMAND_PATTERN = /^[a-zA-Z0-9_-]+$/;

function validateCommand(command: string): void {
  if (!ALLOWED_COMMAND_PATTERN.test(command)) {
    throw new BackendSelectionError(
      `不正なコマンド名: ${command}。英数字、ハイフン、アンダースコアのみ使用可能です。`,
      { command }
    );
  }
  
  // パストラバーサル防止
  if (command.includes("/") || command.includes("\\")) {
    throw new BackendSelectionError(
      `コマンド名にパス区切り文字を含めることはできません: ${command}`,
      { command }
    );
  }
}
```

#### 6.2.2 引数のエスケープ

```typescript
// 配列形式で引数を渡す（シェルインジェクション防止）
async function executeCustomBackend(
  config: CustomBackend,
  prompt: string
): Promise<string> {
  const args = [...config.args];
  
  if (config.prompt_mode === "arg") {
    if (config.prompt_flag) {
      args.push(config.prompt_flag, prompt);
    } else {
      args.push(prompt);
    }
  }
  
  // Bun.spawnは配列形式で引数を受け取るため、シェルインジェクションは発生しない
  const result = await Bun.spawn([config.command, ...args], {
    stdin: config.prompt_mode === "stdin" ? new TextEncoder().encode(prompt) : undefined,
  });
  
  return await new Response(result.stdout).text();
}
```

#### 6.2.3 タイムアウト設定

```typescript
// カスタムバックエンドの実行タイムアウト
const CUSTOM_BACKEND_TIMEOUT_MS = 300000; // 5分

async function executeWithTimeout(
  config: CustomBackend,
  prompt: string
): Promise<string> {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), CUSTOM_BACKEND_TIMEOUT_MS);
  
  try {
    return await executeCustomBackend(config, prompt, controller.signal);
  } finally {
    clearTimeout(timeout);
  }
}
```

---

## 7. イベント発行 セキュリティ（F-020）

### 7.1 リスク

CLIまたはAgent出力からイベントを発行する際、悪意のあるペイロードが注入される可能性があります。

### 7.2 対策

#### 7.2.1 イベントトピックのバリデーション

```typescript
// src/core/event.ts

const TOPIC_PATTERN = /^[a-zA-Z0-9_.-]+$/;
const MAX_TOPIC_LENGTH = 100;

function validateTopic(topic: string): void {
  if (topic.length > MAX_TOPIC_LENGTH) {
    throw new Error(`イベントトピックが長すぎます（最大${MAX_TOPIC_LENGTH}文字）`);
  }
  
  if (!TOPIC_PATTERN.test(topic)) {
    throw new Error(
      `不正なイベントトピック: ${topic}。英数字、ピリオド、ハイフン、アンダースコアのみ使用可能です。`
    );
  }
}
```

#### 7.2.2 JSONペイロードのサイズ制限

```typescript
const MAX_PAYLOAD_SIZE = 10240; // 10KB

function validatePayload(payload: string | Record<string, unknown>): void {
  const serialized = typeof payload === "string" ? payload : JSON.stringify(payload);
  
  if (serialized.length > MAX_PAYLOAD_SIZE) {
    throw new Error(`ペイロードが大きすぎます（最大${MAX_PAYLOAD_SIZE}バイト）`);
  }
}
```

#### 7.2.3 Agent出力からのイベント解析

Agent出力内の`<event>`タグは安全に解析します：

```typescript
// src/core/event-parser.ts

const EVENT_TAG_PATTERN = /<event\s+topic="([^"]+)"(?:\s+target="([^"]+)")?>([\s\S]*?)<\/event>/g;

function parseEventsFromOutput(output: string): EventEmission[] {
  const events: EventEmission[] = [];
  let match;
  
  while ((match = EVENT_TAG_PATTERN.exec(output)) !== null) {
    const [, topic, target, message] = match;
    
    try {
      validateTopic(topic);
      if (target) {
        validateTopic(target); // ターゲットHat名も検証
      }
      validatePayload(message);
      
      events.push({
        topic,
        target,
        message: message.trim(),
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      logger.warn(`不正なイベントをスキップ: ${error.message}`);
    }
  }
  
  return events;
}
```

---

## 8. Glob Pattern セキュリティ（F-021）

### 8.1 リスク

不正なglobパターンによるReDoS（Regular Expression Denial of Service）攻撃の可能性があります。

### 8.2 対策

#### 8.2.1 パターンの事前検証

```typescript
// src/core/glob-matcher.ts

const MAX_PATTERN_LENGTH = 50;
const ALLOWED_GLOB_CHARS = /^[a-zA-Z0-9_.*-]+$/;

function validateGlobPattern(pattern: string): void {
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new GlobPatternError(
      `パターンが長すぎます（最大${MAX_PATTERN_LENGTH}文字）`,
      { pattern }
    );
  }
  
  if (!ALLOWED_GLOB_CHARS.test(pattern)) {
    throw new GlobPatternError(
      `不正な文字が含まれています: ${pattern}`,
      { pattern }
    );
  }
  
  // 連続するワイルドカードを禁止（ReDoS防止）
  if (pattern.includes("**")) {
    throw new GlobPatternError(
      `連続するワイルドカードは許可されていません: ${pattern}`,
      { pattern }
    );
  }
}
```

#### 8.2.2 マッチング時のタイムアウト

```typescript
// マッチング処理のタイムアウト
const MATCH_TIMEOUT_MS = 100;

function matchWithTimeout(pattern: string, topic: string): boolean {
  const startTime = Date.now();
  
  // 簡易的なglobマッチング実装
  const regex = globToRegex(pattern);
  
  if (Date.now() - startTime > MATCH_TIMEOUT_MS) {
    throw new GlobPatternError("パターンマッチングがタイムアウトしました", { pattern, topic });
  }
  
  return regex.test(topic);
}
```

---

## 9. API Rate Limit対策

### 9.1 GitHub API制限

| 認証状態 | 制限 | 時間 |
|---------|------|------|
| 認証済み | 5,000リクエスト | 1時間 |
| 未認証 | 60リクエスト | 1時間 |

### 9.2 対策

v1.3.0で実装済みのレート制限対策をv1.4.0でも継続使用：

- リクエスト数の最小化
- レート制限の監視
- 指数バックオフによるリトライ

---

## 10. ファイルシステムセキュリティ

### 10.1 パストラバーサル防止

```typescript
// src/utils/path-validator.ts

function validatePath(basePath: string, targetPath: string): string {
  const resolved = path.resolve(basePath, targetPath);
  const baseResolved = path.resolve(basePath);
  
  if (!resolved.startsWith(baseResolved)) {
    throw new Error(`パストラバーサルを検出: ${targetPath}`);
  }
  
  return resolved;
}
```

### 10.2 ファイル権限一覧

| ファイル/ディレクトリ | 権限 | 説明 |
|---------------------|------|------|
| `.agent/` | 700 | 所有者のみアクセス可能 |
| `.agent/memories.md` | 600 | 所有者のみ読み書き可能 |
| `.agent/tasks.jsonl` | 600 | 所有者のみ読み書き可能 |
| `*.session.jsonl` | 600 | 所有者のみ読み書き可能 |
| `.orch/loop.lock` | 600 | 所有者のみ読み書き可能 |
| `.orch/loops.json` | 644 | 全員読み取り可能 |
| `.worktrees/` | 700 | 所有者のみアクセス可能 |

---

## 11. 監査ログ

### 11.1 v1.4.0で追加される監査対象

| イベント | 記録内容 | 対象機能 |
|---------|---------|---------|
| memory.add | ID、種別、タグ | F-014 |
| memory.delete | ID | F-014 |
| task.add | ID、タイトル、優先度 | F-015 |
| task.close | ID | F-015 |
| session.start | ファイルパス | F-016 |
| session.end | ファイルパス、エントリ数 | F-016 |
| worktree.create | パス、ブランチ | F-017 |
| worktree.remove | パス | F-017 |
| worktree.merge | ループID、結果 | F-017 |
| backend.custom | コマンド、引数 | F-019 |
| event.emit | トピック、ターゲット | F-020 |

### 11.2 ログフォーマット

```json
{
  "timestamp": "2026-01-26T10:30:00Z",
  "level": "info",
  "event": "worktree.create",
  "data": {
    "path": ".worktrees/orch-20260126-a3f2",
    "branch": "feature/issue-42",
    "loopId": "orch-20260126-a3f2"
  }
}
```

---

## 12. セキュリティチェックリスト

### 12.1 開発時チェック（v1.4.0追加項目）

- [ ] Memories保存前に機密情報がサニタイズされているか
- [ ] Session Recording前に機密情報がマスクされているか
- [ ] カスタムバックエンドのコマンドがバリデーションされているか
- [ ] イベントトピック/ペイロードがバリデーションされているか
- [ ] Globパターンが事前検証されているか

### 12.2 レビュー時チェック（v1.4.0追加項目）

- [ ] worktree間でのファイルパーミッションが適切か
- [ ] シンボリックリンクが相対パスで作成されているか
- [ ] カスタムバックエンドの引数が配列形式で渡されているか
- [ ] タイムアウト設定が適切か

### 12.3 リリース前チェック

- [ ] `.gitignore`に機密ファイルが含まれているか
- [ ] 新規追加されたファイルの権限設定が適切か
- [ ] 監査ログが正しく記録されているか

---

## 13. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| 1.0.0 | 2026-01-26 | 初版作成 | AI Assistant |
