# sandbox サブ機能 バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-001-SANDBOX-BACKEND |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-24 |
| 最終更新日 | 2026-01-24 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-001-SANDBOX v1.0.0 |

---

## 1. 概要

本ドキュメントでは、sandbox サブ機能のバックエンド実装の詳細仕様を定義します。

### 1.1 対象コンポーネント

| コンポーネント | 種別 | 責務 |
|--------------|------|------|
| **BunProcessExecutor** | Class | Bun.spawnのラッパー実装 |
| **DockerAdapter** | Class | Docker環境でのコード実行 |
| **HostAdapter** | Class | ホスト環境でのコード実行 |
| **ContainerAdapter** | Class | container-use環境でのコード実行（リファクタ） |
| **SandboxFactory** | Class | 設定に基づいてAdapterを生成 |

---

## 2. BunProcessExecutor（プロセス実行抽象化）

### 2.1 クラス定義

```typescript
// src/core/bun-process-executor.ts

import type { ProcessExecutor, SpawnOptions, ProcessResult } from "./process-executor.js";

/**
 * Bun.spawnを使用したProcessExecutor実装
 */
export class BunProcessExecutor implements ProcessExecutor {
  /**
   * コマンドを実行する
   * @param command 実行するコマンド
   * @param args コマンド引数
   * @param options 実行オプション
   * @returns 実行結果
   * @throws ExecutionTimeoutError タイムアウト時
   * @throws Error プロセス起動失敗時
   */
  async spawn(
    command: string,
    args: string[],
    options: SpawnOptions = {}
  ): Promise<ProcessResult> {
    // 実装詳細は後述
  }
}
```

### 2.2 メソッド詳細

#### spawn()

**目的**: コマンドを実行し、結果を返す

**パラメータ**:

| パラメータ | 型 | 必須 | デフォルト | 説明 |
|-----------|---|------|-----------|------|
| command | string | ✓ | - | 実行するコマンド（例: "docker", "sh"） |
| args | string[] | ✓ | - | コマンド引数 |
| options.cwd | string | - | process.cwd() | 作業ディレクトリ |
| options.env | Record<string, string> | - | process.env | 環境変数 |
| options.stdin | string | - | undefined | 標準入力データ |
| options.timeout | number | - | undefined | タイムアウト（ミリ秒） |
| options.stdout | "pipe" \| "inherit" | - | "pipe" | 標準出力の処理方法 |
| options.stderr | "pipe" \| "inherit" | - | "pipe" | 標準エラー出力の処理方法 |

**戻り値**: `Promise<ProcessResult>`

| フィールド | 型 | 説明 |
|-----------|---|------|
| stdout | string | 標準出力（options.stdout="pipe"の場合） |
| stderr | string | 標準エラー出力（options.stderr="pipe"の場合） |
| exitCode | number | 終了コード |

**例外**:

| 例外 | 発生条件 |
|------|---------|
| ExecutionTimeoutError | タイムアウト時 |
| Error | プロセス起動失敗時 |

**実装**:

```typescript
async spawn(
  command: string,
  args: string[],
  options: SpawnOptions = {}
): Promise<ProcessResult> {
  // Bun.spawnプロセスを起動
  const proc = Bun.spawn([command, ...args], {
    cwd: options.cwd,
    env: options.env,
    stdin: options.stdin ? "pipe" : undefined,
    stdout: options.stdout ?? "pipe",
    stderr: options.stderr ?? "pipe",
  });

  // タイムアウト処理
  let timeoutId: Timer | undefined;
  if (options.timeout) {
    timeoutId = setTimeout(() => {
      proc.kill();
    }, options.timeout);
  }

  // プロセス終了時にタイムアウトをクリア
  proc.exited.then(() => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  });

  // stdin書き込み
  if (options.stdin && proc.stdin) {
    const writer = proc.stdin.getWriter();
    await writer.write(new TextEncoder().encode(options.stdin));
    await writer.close();
  }

  // 結果取得
  const [stdout, stderr, exitCode] = await Promise.all([
    options.stdout === "pipe" ? new Response(proc.stdout).text() : Promise.resolve(""),
    options.stderr === "pipe" ? new Response(proc.stderr).text() : Promise.resolve(""),
    proc.exited,
  ]);

  // タイムアウトチェック
  if (options.timeout && proc.killed) {
    throw new ExecutionTimeoutError(options.timeout);
  }

  return { stdout, stderr, exitCode };
}
```

### 2.3 使用例

```typescript
const executor = new BunProcessExecutor();

// 基本的な使用
const result = await executor.spawn("echo", ["Hello, World!"]);
console.log(result.stdout); // "Hello, World!\n"

// 環境変数を設定
const result2 = await executor.spawn("printenv", ["MY_VAR"], {
  env: { MY_VAR: "test" },
});

// タイムアウトを設定
try {
  await executor.spawn("sleep", ["10"], { timeout: 1000 });
} catch (error) {
  if (error instanceof ExecutionTimeoutError) {
    console.error("タイムアウトしました");
  }
}
```

---

## 3. DockerAdapter（Docker環境実行）

### 3.1 クラス定義

```typescript
// src/adapters/docker-adapter.ts

import type { SandboxAdapter, ExecuteOptions, ExecuteResult } from "./sandbox-adapter.js";
import type { ProcessExecutor } from "../core/process-executor.js";
import { BunProcessExecutor } from "../core/bun-process-executor.js";
import { ImagePullError } from "./sandbox-errors.js";

/**
 * Docker設定
 */
export interface DockerAdapterConfig {
  /** ベースイメージ */
  image: string;
  
  /** 作業ディレクトリ（デフォルト: process.cwd()） */
  workdir?: string;
  
  /** ネットワーク設定 */
  network?: "none" | "bridge" | "host";
  
  /** タイムアウト（ミリ秒） */
  timeout?: number;
}

/**
 * Dockerコンテナでコードを実行するアダプター
 */
export class DockerAdapter implements SandboxAdapter {
  readonly name = "docker";
  private readonly config: DockerAdapterConfig;
  private readonly executor: ProcessExecutor;

  constructor(
    config: DockerAdapterConfig,
    executor: ProcessExecutor = new BunProcessExecutor()
  ) {
    this.config = config;
    this.executor = executor;
  }

  async isAvailable(): Promise<boolean> { /* 実装詳細は後述 */ }
  async execute(command: string, options?: ExecuteOptions): Promise<ExecuteResult> { /* 実装詳細は後述 */ }
  async cleanup(): Promise<void> { /* 実装詳細は後述 */ }
  
  private async ensureImage(): Promise<void> { /* 実装詳細は後述 */ }
  private buildDockerRunArgs(command: string, options: ExecuteOptions): string[] { /* 実装詳細は後述 */ }
}
```

### 3.2 メソッド詳細

#### isAvailable()

**目的**: Docker環境が利用可能かチェック

**戻り値**: `Promise<boolean>`

**実装**:

```typescript
async isAvailable(): Promise<boolean> {
  try {
    const result = await this.executor.spawn("docker", ["--version"]);
    return result.exitCode === 0;
  } catch {
    return false;
  }
}
```

#### execute()

**目的**: Dockerコンテナ内でコマンドを実行

**パラメータ**:

| パラメータ | 型 | 必須 | デフォルト | 説明 |
|-----------|---|------|-----------|------|
| command | string | ✓ | - | 実行するコマンド |
| options.cwd | string | - | config.workdir | 作業ディレクトリ |
| options.env | Record<string, string> | - | {} | 環境変数 |
| options.timeout | number | - | config.timeout | タイムアウト（ミリ秒） |

**戻り値**: `Promise<ExecuteResult>`

**例外**:

| 例外 | 発生条件 |
|------|---------|
| ImagePullError | イメージpull失敗時 |
| ExecutionTimeoutError | タイムアウト時 |

**実装**:

```typescript
async execute(
  command: string,
  options: ExecuteOptions = {}
): Promise<ExecuteResult> {
  // イメージの存在確認（なければpull）
  await this.ensureImage();

  // docker runコマンドの構築
  const args = this.buildDockerRunArgs(command, options);

  // 実行
  const result = await this.executor.spawn("docker", args, {
    timeout: options.timeout ?? this.config.timeout,
  });

  return {
    stdout: result.stdout,
    stderr: result.stderr,
    exitCode: result.exitCode,
  };
}
```

#### ensureImage()

**目的**: Dockerイメージの存在を確認し、なければpull

**実装**:

```typescript
private async ensureImage(): Promise<void> {
  // イメージの存在確認
  const result = await this.executor.spawn("docker", [
    "image",
    "inspect",
    this.config.image,
  ]);

  if (result.exitCode !== 0) {
    // イメージが存在しない場合はpull
    logger.info(`Dockerイメージをpull中: ${this.config.image}`);
    
    const pullResult = await this.executor.spawn("docker", [
      "pull",
      this.config.image,
    ]);

    if (pullResult.exitCode !== 0) {
      throw new ImagePullError(this.config.image, pullResult.stderr);
    }
    
    logger.success(`Dockerイメージをpullしました: ${this.config.image}`);
  }
}
```

#### buildDockerRunArgs()

**目的**: docker runコマンドの引数を構築

**実装**:

```typescript
private buildDockerRunArgs(
  command: string,
  options: ExecuteOptions
): string[] {
  const args = [
    "run",
    "--rm",  // 実行後に自動削除
    "-i",    // インタラクティブモード
  ];

  // ネットワーク設定
  if (this.config.network) {
    args.push("--network", this.config.network);
  }

  // 作業ディレクトリのマウント
  const workdir = options.cwd ?? this.config.workdir ?? process.cwd();
  args.push("-v", `${workdir}:/workspace`);
  args.push("-w", "/workspace");

  // 環境変数
  if (options.env) {
    for (const [key, value] of Object.entries(options.env)) {
      args.push("-e", `${key}=${value}`);
    }
  }

  // イメージとコマンド
  args.push(this.config.image);
  args.push("sh", "-c", command);

  return args;
}
```

**docker runコマンド例**:

```bash
docker run \
  --rm \
  -i \
  --network none \
  -v /path/to/workdir:/workspace \
  -w /workspace \
  -e NODE_ENV=production \
  node:20-alpine \
  sh -c "npm test"
```

#### cleanup()

**目的**: クリーンアップ（Dockerは--rmで自動削除されるため不要）

**実装**:

```typescript
async cleanup(): Promise<void> {
  // Dockerは--rmで自動削除されるため、特に処理なし
}
```

### 3.3 使用例

```typescript
const adapter = new DockerAdapter({
  image: "node:20-alpine",
  network: "none",
  timeout: 300000, // 5分
});

// 利用可能性チェック
if (await adapter.isAvailable()) {
  // コマンド実行
  const result = await adapter.execute("npm test", {
    env: { NODE_ENV: "test" },
  });
  
  console.log(result.stdout);
  console.log(`Exit code: ${result.exitCode}`);
}
```

---

## 4. HostAdapter（ホスト環境実行）

### 4.1 クラス定義

```typescript
// src/adapters/host-adapter.ts

import type { SandboxAdapter, ExecuteOptions, ExecuteResult } from "./sandbox-adapter.js";
import type { ProcessExecutor } from "../core/process-executor.js";
import { BunProcessExecutor } from "../core/bun-process-executor.js";
import { logger } from "../core/logger.js";

/**
 * ホスト環境設定
 */
export interface HostAdapterConfig {
  /** タイムアウト（ミリ秒） */
  timeout?: number;
  
  /** 起動時に警告を表示するか */
  warnOnStart?: boolean;
}

/**
 * ホスト環境で直接コードを実行するアダプター
 * 
 * ⚠️ セキュリティ警告:
 * このアダプターは隔離されていない環境でコードを実行します。
 * 本番環境ではDockerまたはcontainer-useの使用を推奨します。
 */
export class HostAdapter implements SandboxAdapter {
  readonly name = "host";
  private readonly config: HostAdapterConfig;
  private readonly executor: ProcessExecutor;
  private hasWarned = false;

  constructor(
    config: HostAdapterConfig = {},
    executor: ProcessExecutor = new BunProcessExecutor()
  ) {
    this.config = config;
    this.executor = executor;
  }

  async isAvailable(): Promise<boolean> { /* 実装詳細は後述 */ }
  async execute(command: string, options?: ExecuteOptions): Promise<ExecuteResult> { /* 実装詳細は後述 */ }
  async cleanup(): Promise<void> { /* 実装詳細は後述 */ }
}
```

### 4.2 メソッド詳細

#### isAvailable()

**目的**: ホスト環境は常に利用可能

**実装**:

```typescript
async isAvailable(): Promise<boolean> {
  // ホスト環境は常に利用可能
  return true;
}
```

#### execute()

**目的**: ホスト環境でコマンドを実行

**実装**:

```typescript
async execute(
  command: string,
  options: ExecuteOptions = {}
): Promise<ExecuteResult> {
  // 初回実行時に警告を表示
  if (!this.hasWarned && (this.config.warnOnStart ?? true)) {
    logger.warn(
      "⚠️  ホスト環境で実行中: コードは隔離されていません。\n" +
      "   本番環境ではDockerまたはcontainer-useの使用を推奨します。"
    );
    this.hasWarned = true;
  }

  // シェル経由でコマンドを実行
  const result = await this.executor.spawn("sh", ["-c", command], {
    cwd: options.cwd,
    env: options.env,
    timeout: options.timeout ?? this.config.timeout,
  });

  return {
    stdout: result.stdout,
    stderr: result.stderr,
    exitCode: result.exitCode,
  };
}
```

#### cleanup()

**目的**: クリーンアップ（ホスト環境では不要）

**実装**:

```typescript
async cleanup(): Promise<void> {
  // ホスト環境では特にクリーンアップ不要
}
```

### 4.3 使用例

```typescript
const adapter = new HostAdapter({
  timeout: 300000, // 5分
  warnOnStart: true,
});

// コマンド実行（初回は警告が表示される）
const result = await adapter.execute("npm test");

// 2回目以降は警告なし
const result2 = await adapter.execute("npm run build");
```

---

## 5. ContainerAdapter（リファクタリング）

### 5.1 変更内容

既存の `ContainerBackend` を `SandboxAdapter` インターフェースに適合させます。

**変更前**:

```typescript
// src/adapters/container.ts
export class ContainerBackend extends BaseBackend {
  readonly name = "container";
  
  async execute(prompt: string): Promise<BackendResult> {
    // ...
  }
}
```

**変更後**:

```typescript
// src/adapters/container-adapter.ts
export class ContainerAdapter implements SandboxAdapter {
  readonly name = "container-use";
  
  constructor(
    config: ContainerAdapterConfig = {},
    executor: ProcessExecutor = new BunProcessExecutor()
  ) {
    this.config = config;
    this.executor = executor;
  }
  
  async execute(command: string, options?: ExecuteOptions): Promise<ExecuteResult> {
    // ...
  }
  
  async cleanup(): Promise<void> {
    // ...
  }
  
  async isAvailable(): Promise<boolean> {
    // ...
  }
}
```

### 5.2 クラス定義

```typescript
// src/adapters/container-adapter.ts

import type { SandboxAdapter, ExecuteOptions, ExecuteResult } from "./sandbox-adapter.js";
import type { ProcessExecutor } from "../core/process-executor.js";
import { BunProcessExecutor } from "../core/bun-process-executor.js";
import { logger } from "../core/logger.js";

/**
 * container-use設定
 */
export interface ContainerAdapterConfig {
  /** ベースイメージ */
  image?: string;
  
  /** 作業ディレクトリ */
  workdir?: string;
  
  /** 既存の環境ID（再利用する場合） */
  envId?: string;
}

/**
 * container-use環境でコードを実行するアダプター
 */
export class ContainerAdapter implements SandboxAdapter {
  readonly name = "container-use";
  private envId: string | null = null;
  private readonly config: ContainerAdapterConfig;
  private readonly executor: ProcessExecutor;

  constructor(
    config: ContainerAdapterConfig = {},
    executor: ProcessExecutor = new BunProcessExecutor()
  ) {
    this.config = config;
    this.executor = executor;
    this.envId = config.envId ?? null;
  }

  async isAvailable(): Promise<boolean> { /* 実装詳細は後述 */ }
  async execute(command: string, options?: ExecuteOptions): Promise<ExecuteResult> { /* 実装詳細は後述 */ }
  async cleanup(): Promise<void> { /* 実装詳細は後述 */ }
  
  private async createEnvironment(): Promise<void> { /* 実装詳細は後述 */ }
  private async runInContainer(command: string, options: ExecuteOptions): Promise<ExecuteResult> { /* 実装詳細は後述 */ }
  
  getEnvironmentId(): string | null { return this.envId; }
}
```

### 5.3 メソッド詳細

#### isAvailable()

**実装**:

```typescript
async isAvailable(): Promise<boolean> {
  try {
    const result = await this.executor.spawn("cu", ["--version"]);
    return result.exitCode === 0;
  } catch {
    return false;
  }
}
```

#### execute()

**実装**:

```typescript
async execute(
  command: string,
  options: ExecuteOptions = {}
): Promise<ExecuteResult> {
  // 環境が未作成なら作成
  if (!this.envId) {
    await this.createEnvironment();
  }

  // コンテナ内で実行
  const result = await this.runInContainer(command, options);
  return result;
}
```

#### createEnvironment()

**実装**:

```typescript
private async createEnvironment(): Promise<void> {
  logger.info("container-use環境を作成中...");

  const workdir = this.config.workdir ?? process.cwd();

  const result = await this.executor.spawn("cu", [
    "environment",
    "create",
    "--source",
    workdir,
    "--title",
    "orchestrator-hybrid",
    "--json",
  ]);

  if (result.exitCode !== 0) {
    throw new Error(`環境作成に失敗: ${result.stderr}`);
  }

  const data = JSON.parse(result.stdout);
  this.envId = data.environment_id;

  logger.success(`環境を作成しました: ${this.envId}`);
}
```

#### runInContainer()

**実装**:

```typescript
private async runInContainer(
  command: string,
  options: ExecuteOptions
): Promise<ExecuteResult> {
  if (!this.envId) {
    throw new Error("環境IDが設定されていません");
  }

  const workdir = options.cwd ?? this.config.workdir ?? process.cwd();

  const result = await this.executor.spawn(
    "cu",
    [
      "environment",
      "run",
      "--id",
      this.envId,
      "--source",
      workdir,
      "--command",
      command,
    ],
    {
      timeout: options.timeout,
    }
  );

  return {
    stdout: result.stdout,
    stderr: result.stderr,
    exitCode: result.exitCode,
  };
}
```

#### cleanup()

**実装**:

```typescript
async cleanup(): Promise<void> {
  if (!this.envId) {
    return;
  }

  logger.info(`環境をクリーンアップ中: ${this.envId}`);

  try {
    const workdir = this.config.workdir ?? process.cwd();
    
    await this.executor.spawn("cu", [
      "environment",
      "delete",
      "--id",
      this.envId,
      "--source",
      workdir,
    ]);
    
    logger.success("環境を削除しました");
  } catch (error) {
    logger.warn(`環境削除に失敗: ${error.message}`);
  }

  this.envId = null;
}
```

---

## 6. SandboxFactory（環境選択）

### 6.1 クラス定義

```typescript
// src/adapters/sandbox-factory.ts

import type { SandboxAdapter } from "./sandbox-adapter.js";
import type { ProcessExecutor } from "../core/process-executor.js";
import type { Config } from "../core/types.js";
import { DockerAdapter } from "./docker-adapter.js";
import { ContainerAdapter } from "./container-adapter.js";
import { HostAdapter } from "./host-adapter.js";
import { EnvironmentUnavailableError } from "./sandbox-errors.js";
import { logger } from "../core/logger.js";

/**
 * サンドボックスアダプターを生成するファクトリー
 */
export class SandboxFactory {
  /**
   * 設定に基づいてSandboxAdapterを生成
   * @param config 設定
   * @param executor ProcessExecutor（テスト時のモック用）
   * @returns SandboxAdapter
   * @throws EnvironmentUnavailableError 利用可能な環境がない場合
   */
  static async create(
    config: Config,
    executor?: ProcessExecutor
  ): Promise<SandboxAdapter> {
    const sandboxType = config.sandbox?.type ?? "container-use";
    const fallbackType = config.sandbox?.fallback;

    // プライマリ環境を試行
    const primaryAdapter = this.createAdapter(sandboxType, config, executor);
    if (await primaryAdapter.isAvailable()) {
      logger.info(`サンドボックス環境: ${sandboxType}`);
      return primaryAdapter;
    }

    // フォールバック環境を試行
    if (fallbackType) {
      logger.warn(
        `${sandboxType}が利用できません。${fallbackType}にフォールバックします。`
      );
      
      const fallbackAdapter = this.createAdapter(fallbackType, config, executor);
      if (await fallbackAdapter.isAvailable()) {
        logger.info(`サンドボックス環境: ${fallbackType} (フォールバック)`);
        return fallbackAdapter;
      }
    }

    // どちらも利用できない場合はエラー
    throw new EnvironmentUnavailableError(
      sandboxType + (fallbackType ? `, ${fallbackType}` : "")
    );
  }

  /**
   * 指定されたタイプのアダプターを生成
   * @param type サンドボックスタイプ
   * @param config 設定
   * @param executor ProcessExecutor
   * @returns SandboxAdapter
   * @throws Error 未知のタイプの場合
   */
  private static createAdapter(
    type: string,
    config: Config,
    executor?: ProcessExecutor
  ): SandboxAdapter {
    switch (type) {
      case "docker":
        return new DockerAdapter(
          {
            image: config.sandbox?.docker?.image ?? "node:20-alpine",
            network: config.sandbox?.docker?.network,
            timeout: (config.sandbox?.docker?.timeout ?? 300) * 1000, // 秒→ミリ秒
          },
          executor
        );

      case "container-use":
        return new ContainerAdapter(
          {
            image: config.sandbox?.containerUse?.image,
            envId: config.sandbox?.containerUse?.envId,
          },
          executor
        );

      case "host":
        return new HostAdapter(
          {
            timeout: (config.sandbox?.host?.timeout ?? 300) * 1000, // 秒→ミリ秒
            warnOnStart: config.sandbox?.host?.warnOnStart,
          },
          executor
        );

      default:
        throw new Error(`未知のサンドボックスタイプ: ${type}`);
    }
  }
}
```

### 6.2 使用例

```typescript
import { SandboxFactory } from "./adapters/sandbox-factory.js";
import { loadConfig } from "./core/config.js";

// 設定読み込み
const config = await loadConfig("orch.yml");

// アダプター生成（自動選択）
const adapter = await SandboxFactory.create(config);

// コマンド実行
const result = await adapter.execute("npm test");

// クリーンアップ
await adapter.cleanup();
```

### 6.3 フォールバック動作例

**設定ファイル**:

```yaml
sandbox:
  type: docker
  fallback: host
```

**動作**:

1. Dockerが利用可能 → DockerAdapterを使用
2. Dockerが利用不可 → 警告ログを出力し、HostAdapterを使用
3. 両方とも利用不可 → EnvironmentUnavailableErrorをスロー

---

## 7. エラークラス定義

### 7.1 基底クラス

```typescript
// src/adapters/sandbox-errors.ts

/**
 * サンドボックス関連エラーの基底クラス
 */
export class SandboxError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly details?: unknown
  ) {
    super(message);
    this.name = "SandboxError";
  }
}
```

### 7.2 具体的なエラークラス

```typescript
/**
 * 環境が利用できない場合のエラー
 */
export class EnvironmentUnavailableError extends SandboxError {
  constructor(environmentType: string) {
    super(
      `サンドボックス環境が利用できません: ${environmentType}`,
      "ENVIRONMENT_UNAVAILABLE",
      { environmentType }
    );
  }
}

/**
 * 実行タイムアウトエラー
 */
export class ExecutionTimeoutError extends SandboxError {
  constructor(timeout: number) {
    super(
      `実行がタイムアウトしました: ${timeout}ms`,
      "EXECUTION_TIMEOUT",
      { timeout }
    );
  }
}

/**
 * Dockerイメージpull失敗エラー
 */
export class ImagePullError extends SandboxError {
  constructor(image: string, stderr: string) {
    super(
      `Dockerイメージの取得に失敗しました: ${image}`,
      "IMAGE_PULL_FAILED",
      { image, stderr }
    );
  }
}

/**
 * 環境作成失敗エラー
 */
export class EnvironmentCreationError extends SandboxError {
  constructor(message: string, stderr: string) {
    super(
      `環境の作成に失敗しました: ${message}`,
      "ENVIRONMENT_CREATION_FAILED",
      { stderr }
    );
  }
}
```

---

## 8. 既存コードの移行

### 8.1 src/core/exec.ts の変更

**変更前**:

```typescript
// src/core/exec.ts
export async function exec(
  cmd: string,
  args: string[],
  options: ExecOptions = {},
): Promise<ExecResult> {
  const { reject = true } = options;

  const proc = Bun.spawn([cmd, ...args], {
    stdout: "pipe",
    stderr: "pipe",
  });

  const stdout = await new Response(proc.stdout).text();
  const exitCode = await proc.exited;

  if (reject && exitCode !== 0) {
    const stderr = await new Response(proc.stderr).text();
    throw new Error(`Command failed with exit code ${exitCode}: ${stderr || stdout}`);
  }

  return { stdout, exitCode };
}
```

**変更後**:

```typescript
// src/core/exec.ts
import { BunProcessExecutor } from "./bun-process-executor.js";

const executor = new BunProcessExecutor();

export async function exec(
  cmd: string,
  args: string[],
  options: ExecOptions = {},
): Promise<ExecResult> {
  const { reject = true } = options;

  const result = await executor.spawn(cmd, args);

  if (reject && result.exitCode !== 0) {
    throw new Error(
      `Command failed with exit code ${result.exitCode}: ${result.stderr || result.stdout}`
    );
  }

  return { stdout: result.stdout, exitCode: result.exitCode };
}
```

### 8.2 src/core/loop.ts の変更

**変更前**:

```typescript
// src/core/loop.ts
import { ContainerBackend } from "../adapters/container.js";

const backend = new ContainerBackend(config.container);
const result = await backend.execute(prompt);
```

**変更後**:

```typescript
// src/core/loop.ts
import { SandboxFactory } from "../adapters/sandbox-factory.js";

const adapter = await SandboxFactory.create(config);
const result = await adapter.execute(command);

// ループ終了時
await adapter.cleanup();
```

---

## 9. テストコード例

### 9.1 BunProcessExecutor のテスト

```typescript
// src/core/bun-process-executor.test.ts

import { describe, it, expect } from "bun:test";
import { BunProcessExecutor } from "./bun-process-executor.js";
import { ExecutionTimeoutError } from "../adapters/sandbox-errors.js";

describe("BunProcessExecutor", () => {
  const executor = new BunProcessExecutor();

  it("should execute command successfully", async () => {
    const result = await executor.spawn("echo", ["Hello, World!"]);
    
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("Hello, World!");
  });

  it("should pass environment variables", async () => {
    const result = await executor.spawn("printenv", ["MY_VAR"], {
      env: { MY_VAR: "test_value" },
    });
    
    expect(result.stdout).toContain("test_value");
  });

  it("should timeout long-running command", async () => {
    await expect(
      executor.spawn("sleep", ["10"], { timeout: 100 })
    ).rejects.toThrow(ExecutionTimeoutError);
  });

  it("should handle non-existent command", async () => {
    await expect(
      executor.spawn("nonexistent-command", [])
    ).rejects.toThrow();
  });
});
```

### 9.2 DockerAdapter のテスト

```typescript
// src/adapters/docker-adapter.test.ts

import { describe, it, expect, beforeAll } from "bun:test";
import { DockerAdapter } from "./docker-adapter.js";

describe("DockerAdapter", () => {
  let adapter: DockerAdapter;

  beforeAll(() => {
    adapter = new DockerAdapter({
      image: "node:20-alpine",
      network: "none",
    });
  });

  it("should check Docker availability", async () => {
    const available = await adapter.isAvailable();
    expect(typeof available).toBe("boolean");
  });

  it("should execute command in Docker", async () => {
    if (!(await adapter.isAvailable())) {
      return; // Dockerが利用できない環境ではスキップ
    }

    const result = await adapter.execute("echo 'Hello from Docker'");
    
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("Hello from Docker");
  });

  it("should mount working directory", async () => {
    if (!(await adapter.isAvailable())) {
      return;
    }

    const result = await adapter.execute("ls -la");
    
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toContain("package.json");
  });
});
```

### 9.3 SandboxFactory のテスト

```typescript
// src/adapters/sandbox-factory.test.ts

import { describe, it, expect } from "bun:test";
import { SandboxFactory } from "./sandbox-factory.js";
import type { Config } from "../core/types.js";

describe("SandboxFactory", () => {
  it("should create Docker adapter when available", async () => {
    const config: Config = {
      sandbox: {
        type: "docker",
        docker: {
          image: "node:20-alpine",
        },
      },
    };

    const adapter = await SandboxFactory.create(config);
    expect(adapter.name).toBe("docker");
  });

  it("should fallback to host when Docker unavailable", async () => {
    const config: Config = {
      sandbox: {
        type: "docker",
        fallback: "host",
      },
    };

    // Dockerが利用できない環境を想定
    const adapter = await SandboxFactory.create(config);
    
    // DockerまたはHostのいずれか
    expect(["docker", "host"]).toContain(adapter.name);
  });

  it("should throw error when no environment available", async () => {
    const config: Config = {
      sandbox: {
        type: "nonexistent" as any,
      },
    };

    await expect(
      SandboxFactory.create(config)
    ).rejects.toThrow();
  });
});
```

---

## 10. パフォーマンス考慮事項

### 10.1 Dockerイメージのキャッシュ

- `ensureImage()` でイメージの存在を確認し、不要なpullを回避
- 初回実行時のみイメージをpull、2回目以降はキャッシュを使用

### 10.2 タイムアウト設定

| 環境 | デフォルトタイムアウト | 推奨値 |
|------|---------------------|--------|
| Docker | 300秒（5分） | 長時間実行が必要な場合は延長 |
| container-use | 設定なし | 必要に応じて設定 |
| Host | 300秒（5分） | 長時間実行が必要な場合は延長 |

### 10.3 並列実行

- 複数のSandboxAdapterインスタンスを並列実行可能
- Dockerの場合、`--rm`により自動クリーンアップされるため、リソースリークなし

---

## 11. セキュリティ考慮事項

### 11.1 Docker環境

| 対策 | 設定 | 効果 |
|------|------|------|
| ネットワーク隔離 | `--network none` | 外部通信を遮断 |
| 自動削除 | `--rm` | コンテナの残留を防止 |
| 読み取り専用マウント | `-v workdir:/workspace:ro` | ファイル改ざん防止（オプション） |

### 11.2 ホスト環境

- **警告表示**: 初回実行時に必ず警告を表示
- **本番環境での使用を非推奨**: ドキュメントで明記
- **環境変数の制限**: 必要最小限の環境変数のみ渡す

---

## 12. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| 1.0.0 | 2026-01-24 | 初版作成 | AI Assistant |
