# 改善Issue自動作成 バックエンド設計書

## メタ情報

| 項目 | 内容 |
|------|------|
| ドキュメントID | DETAILED-ORCH-001-ISSUE-GEN-BACKEND |
| バージョン | 1.0.0 |
| ステータス | ドラフト |
| 作成日 | 2026-01-24 |
| 最終更新日 | 2026-01-24 |
| 作成者 | AI Assistant |
| 承認者 | - |
| 関連詳細設計書 | DETAILED-ORCH-001-ISSUE-GEN v1.0.0 |
| 関連基本設計書 | BASIC-ORCH-001 v1.0.0 |
| 対象機能 | F-006, F-007 |

---

## 1. 概要

### 1.1 目的

IssueGeneratorクラスおよび関連する型定義・関数の詳細仕様を定義し、実装者が迷わずコーディングできる状態にする。

### 1.2 実装ファイル構成

- `src/output/issue-generator.ts` - IssueGeneratorクラス（新規）
- `src/output/issue-generator.test.ts` - 単体テスト（新規）
- `src/core/types.ts` - 型定義追加
- `src/core/loop.ts` - 統合処理追加
- `src/utils/improvement-extractor.ts` - 改善点抽出ユーティリティ（新規）

---

## 2. 型定義

### 2.1 ImprovementSuggestion インターフェース

**ファイル**: `src/core/types.ts`

```typescript
/**
 * 改善提案を表すデータ構造
 */
export interface ImprovementSuggestion {
  /** Issue タイトル（必須） */
  title: string;
  
  /** Issue 本文（Markdown形式、必須） */
  description: string;
  
  /** 優先度（必須） */
  priority: "high" | "medium" | "low";
  
  /** 関連ファイルパス（必須、空配列可） */
  relatedFiles: string[];
  
  /** カテゴリ（オプション） */
  category?: "refactoring" | "performance" | "security" | "documentation" | "testing";
  
  /** メタデータ（オプション） */
  metadata?: {
    /** 一意識別子（ハッシュ） */
    id: string;
    /** 抽出元 */
    source: "scratchpad" | "events" | "output";
    /** 抽出日時 */
    extractedAt: Date;
  };
}
```

### 2.2 IssueGeneratorConfig インターフェース

**ファイル**: `src/core/types.ts`

```typescript
/**
 * IssueGenerator設定
 */
export interface IssueGeneratorConfig {
  /** Issue自動作成の有効/無効（必須） */
  enabled: boolean;
  
  /** 最低優先度閾値（必須） */
  minPriority: "high" | "medium" | "low";
  
  /** 自動付与ラベル（必須、空配列可） */
  labels: string[];
  
  /** 対象リポジトリ（オプション、空文字列=カレントリポジトリ） */
  repository?: string;
  
  /** 重複チェックの有効/無効（オプション、デフォルト: true） */
  duplicateCheckEnabled?: boolean;
  
  /** カスタムテンプレートパス（オプション） */
  templatePath?: string;
}
```

### 2.3 Zodスキーマ定義

**ファイル**: `src/core/types.ts`

```typescript
import { z } from "zod";

/**
 * autoIssue設定のZodスキーマ
 */
export const AutoIssueConfigSchema = z.object({
  enabled: z.boolean().default(false),
  minPriority: z.enum(["high", "medium", "low"]).default("medium"),
  labels: z.array(z.string()).default(["auto-generated", "improvement"]),
  repository: z.string().optional(),
  duplicateCheckEnabled: z.boolean().default(true),
  templatePath: z.string().optional(),
});

/**
 * Config全体のスキーマに追加
 */
export const ConfigSchema = z.object({
  // ... 既存のフィールド
  autoIssue: AutoIssueConfigSchema.optional(),
});
```

---

## 3. IssueGeneratorクラス

### 3.1 クラス定義

**ファイル**: `src/output/issue-generator.ts`

```typescript
import type { ProcessExecutor } from "../core/process-executor.js";
import { BunProcessExecutor } from "../core/bun-process-executor.js";
import { logger } from "../core/logger.js";
import type { ImprovementSuggestion, IssueGeneratorConfig } from "../core/types.js";

/**
 * 改善提案からGitHub Issueを自動作成するクラス
 */
export class IssueGenerator {
  private readonly config: IssueGeneratorConfig;
  private readonly executor: ProcessExecutor;

  /**
   * コンストラクタ
   * @param config Issue作成設定
   * @param executor プロセス実行インターフェース（テスト用にDI可能）
   */
  constructor(
    config: IssueGeneratorConfig,
    executor: ProcessExecutor = new BunProcessExecutor()
  ) {
    this.config = config;
    this.executor = executor;
  }

  /**
   * 複数の改善提案からIssueを作成
   * @param suggestions 改善提案配列
   * @returns 作成されたIssue URL配列
   */
  async createIssues(
    suggestions: ImprovementSuggestion[]
  ): Promise<string[]> {
    if (!this.config.enabled) {
      logger.info("Issue自動作成は無効です");
      return [];
    }

    // gh CLI利用可能性チェック
    if (!(await this.isGhCliAvailable())) {
      logger.warn("gh CLIが利用できません。Issue自動作成をスキップします。");
      return [];
    }

    const createdIssues: string[] = [];

    for (const suggestion of suggestions) {
      try {
        // 優先度フィルタ
        if (!this.shouldCreateIssue(suggestion.priority)) {
          logger.debug(
            `優先度が低いためスキップ: ${suggestion.title} (${suggestion.priority})`
          );
          continue;
        }

        // 重複チェック
        if (await this.isDuplicate(suggestion)) {
          logger.debug(`重複のためスキップ: ${suggestion.title}`);
          continue;
        }

        // Issue作成
        const issueUrl = await this.createIssue(suggestion);
        createdIssues.push(issueUrl);
        logger.success(`Issue作成: ${issueUrl}`);
      } catch (error) {
        logger.error(
          `Issue作成に失敗: ${suggestion.title}`,
          error instanceof Error ? error.message : String(error)
        );
        // 次の提案へ続行
      }
    }

    return createdIssues;
  }

  /**
   * gh CLIが利用可能かチェック
   * @returns 利用可能ならtrue
   */
  private async isGhCliAvailable(): Promise<boolean> {
    try {
      const result = await this.executor.spawn("gh", ["--version"]);
      return result.exitCode === 0;
    } catch {
      return false;
    }
  }

  /**
   * 優先度に基づいてIssue作成すべきか判定
   * @param priority 改善提案の優先度
   * @returns 作成すべきならtrue
   */
  private shouldCreateIssue(priority: string): boolean {
    const priorityOrder: Record<string, number> = {
      high: 3,
      medium: 2,
      low: 1,
    };

    const minPriorityValue = priorityOrder[this.config.minPriority];
    const suggestionPriorityValue = priorityOrder[priority];

    return suggestionPriorityValue >= minPriorityValue;
  }

  /**
   * 既存Issueとの重複をチェック
   * @param suggestion 改善提案
   * @returns 重複ありならtrue
   */
  private async isDuplicate(
    suggestion: ImprovementSuggestion
  ): Promise<boolean> {
    if (!this.config.duplicateCheckEnabled) {
      return false;
    }

    try {
      // タイトルで検索
      const searchQuery = `in:title "${suggestion.title}"`;

      const result = await this.executor.spawn("gh", [
        "issue",
        "list",
        "--search",
        searchQuery,
        "--state",
        "open",
        "--json",
        "title,number",
        "--limit",
        "10",
      ]);

      if (result.exitCode !== 0) {
        logger.warn("重複チェックに失敗しました。Issue作成を続行します。");
        return false;
      }

      const issues = JSON.parse(result.stdout);

      // 完全一致チェック
      return issues.some(
        (issue: { title: string }) =>
          issue.title.toLowerCase() === suggestion.title.toLowerCase()
      );
    } catch (error) {
      logger.warn(
        "重複チェック中にエラーが発生しました。Issue作成を続行します。",
        error instanceof Error ? error.message : String(error)
      );
      return false;
    }
  }

  /**
   * GitHub Issueを作成
   * @param suggestion 改善提案
   * @returns 作成されたIssue URL
   */
  private async createIssue(
    suggestion: ImprovementSuggestion
  ): Promise<string> {
    const body = this.buildIssueBody(suggestion);
    const labels = this.buildLabels(suggestion);

    // 一時ファイルにbodyを書き込み（シェルエスケープ問題を回避）
    const tempFilePath = "/tmp/orch-issue-body.md";
    await Bun.write(tempFilePath, body);

    const args = [
      "issue",
      "create",
      "--title",
      suggestion.title,
      "--body-file",
      tempFilePath,
      "--label",
      labels.join(","),
    ];

    // リポジトリ指定がある場合
    if (this.config.repository) {
      args.push("--repo", this.config.repository);
    }

    const result = await this.executor.spawn("gh", args);

    if (result.exitCode !== 0) {
      throw new Error(`Issue作成に失敗: ${result.stderr}`);
    }

    // URLを抽出
    const match = result.stdout.match(/https:\/\/github\.com\/[^\s]+/);
    return match ? match[0] : result.stdout.trim();
  }

  /**
   * Issue本文を構築
   * @param suggestion 改善提案
   * @returns Markdown形式のIssue本文
   */
  private buildIssueBody(suggestion: ImprovementSuggestion): string {
    // カスタムテンプレートがあれば使用
    if (this.config.templatePath) {
      return this.buildIssueBodyFromTemplate(suggestion);
    }

    // デフォルトテンプレート
    const relatedFilesMarkdown = suggestion.relatedFiles
      .map((file) => `- \`${file}\``)
      .join("\n");

    const categorySection = suggestion.category
      ? `### カテゴリ\n${suggestion.category}\n\n`
      : "";

    const metadataSection = suggestion.metadata
      ? `### メタデータ\n<!-- \nMETADATA: ${JSON.stringify(suggestion.metadata)}\n-->\n\n`
      : "";

    return `## 改善提案

### 概要
${suggestion.description}

### 優先度
${suggestion.priority}

${categorySection}### 関連ファイル
${relatedFilesMarkdown || "なし"}

### 提案者
ralph-loop (自動生成)

${metadataSection}---
*このIssueは自動生成されました*
`;
  }

  /**
   * カスタムテンプレートからIssue本文を構築
   * @param suggestion 改善提案
   * @returns Markdown形式のIssue本文
   */
  private buildIssueBodyFromTemplate(
    suggestion: ImprovementSuggestion
  ): string {
    // 将来実装: テンプレートファイルを読み込み、プレースホルダーを置換
    // 現在はデフォルトテンプレートを使用
    return this.buildIssueBody(suggestion);
  }

  /**
   * Issue作成時に付与するラベルを構築
   * @param suggestion 改善提案
   * @returns ラベル配列
   */
  private buildLabels(suggestion: ImprovementSuggestion): string[] {
    const labels = [...this.config.labels];

    // 優先度ラベル
    labels.push(`priority:${suggestion.priority}`);

    // カテゴリラベル
    if (suggestion.category) {
      labels.push(`category:${suggestion.category}`);
    }

    return labels;
  }
}
```

---

## 4. 改善点抽出ユーティリティ

### 4.1 extractImprovements() 関数

**ファイル**: `src/utils/improvement-extractor.ts`

```typescript
import { readScratchpad } from "../core/scratchpad.js";
import type { ImprovementSuggestion, LoopContext } from "../core/types.js";
import { logger } from "../core/logger.js";
import crypto from "node:crypto";

/**
 * ループコンテキストから改善提案を抽出
 * @param context ループコンテキスト
 * @returns 改善提案配列
 */
export async function extractImprovements(
  context: LoopContext
): Promise<ImprovementSuggestion[]> {
  const suggestions: ImprovementSuggestion[] = [];

  try {
    // 1. Scratchpadから抽出
    const scratchpadSuggestions = await extractFromScratchpad(
      context.scratchpadPath
    );
    suggestions.push(...scratchpadSuggestions);

    logger.debug(`${suggestions.length}件の改善提案を抽出しました`);
  } catch (error) {
    logger.warn(
      "改善提案の抽出に失敗しました",
      error instanceof Error ? error.message : String(error)
    );
  }

  return suggestions;
}

/**
 * Scratchpadから改善提案を抽出
 * @param scratchpadPath Scratchpadファイルパス
 * @returns 改善提案配列
 */
async function extractFromScratchpad(
  scratchpadPath: string
): Promise<ImprovementSuggestion[]> {
  const content = readScratchpad(scratchpadPath);
  const suggestions: ImprovementSuggestion[] = [];

  // 改善提案マーカーのパターン
  const pattern =
    /<!-- IMPROVEMENT_START (.*?) -->([\s\S]*?)<!-- IMPROVEMENT_END -->/g;
  let match: RegExpExecArray | null;

  while ((match = pattern.exec(content)) !== null) {
    try {
      const metadata = parseMetadata(match[1]);
      const body = match[2].trim();

      const titleMatch = body.match(/\*\*タイトル\*\*:\s*(.+)/);
      const descMatch = body.match(/\*\*説明\*\*:\s*([\s\S]*?)(?=\*\*|$)/);
      const filesMatch = body.match(/\*\*関連ファイル\*\*:\s*([\s\S]*?)(?=\*\*|$)/);

      if (titleMatch && descMatch) {
        const title = titleMatch[1].trim();
        const description = descMatch[1].trim();

        suggestions.push({
          title,
          description,
          priority: metadata.priority ?? "medium",
          category: metadata.category,
          relatedFiles: parseRelatedFiles(filesMatch?.[1] ?? ""),
          metadata: {
            id: generateHash(title),
            source: "scratchpad",
            extractedAt: new Date(),
          },
        });
      }
    } catch (error) {
      logger.warn(
        "改善提案のパース中にエラーが発生しました",
        error instanceof Error ? error.message : String(error)
      );
      // 次のマッチへ続行
    }
  }

  return suggestions;
}

/**
 * メタデータ文字列をパース
 * @param metadataStr メタデータ文字列（例: "priority:high category:refactoring"）
 * @returns パースされたメタデータ
 */
function parseMetadata(metadataStr: string): {
  priority?: "high" | "medium" | "low";
  category?: ImprovementSuggestion["category"];
} {
  const metadata: {
    priority?: "high" | "medium" | "low";
    category?: ImprovementSuggestion["category"];
  } = {};

  const priorityMatch = metadataStr.match(/priority:(high|medium|low)/);
  if (priorityMatch) {
    metadata.priority = priorityMatch[1] as "high" | "medium" | "low";
  }

  const categoryMatch = metadataStr.match(
    /category:(refactoring|performance|security|documentation|testing)/
  );
  if (categoryMatch) {
    metadata.category = categoryMatch[1] as ImprovementSuggestion["category"];
  }

  return metadata;
}

/**
 * 関連ファイル文字列をパース
 * @param filesStr 関連ファイル文字列（例: "- src/file1.ts\n- src/file2.ts"）
 * @returns ファイルパス配列
 */
function parseRelatedFiles(filesStr: string): string[] {
  const lines = filesStr.split("\n").filter(Boolean);
  return lines
    .map((line) => {
      const match = line.match(/^-\s*`?(.+?)`?$/);
      return match ? match[1].trim() : null;
    })
    .filter((file): file is string => file !== null);
}

/**
 * 文字列からハッシュを生成
 * @param str 入力文字列
 * @returns SHA-256ハッシュ（短縮版）
 */
function generateHash(str: string): string {
  return crypto.createHash("sha256").update(str).digest("hex").slice(0, 8);
}
```

---

## 5. ループエンジンへの統合

### 5.1 loop.ts への追加

**ファイル**: `src/core/loop.ts`

```typescript
import { IssueGenerator } from "../output/issue-generator.js";
import { extractImprovements } from "../utils/improvement-extractor.js";

// executeLoop() 関数内、ループ完了後に追加
async function handleLoopEnd(
  context: LoopContext,
  config: Config,
  collector: ReportCollector | null,
  eventBus: EventBus | null,
  state: LoopState,
  issueNumber: number,
  taskId?: string,
): Promise<void> {
  const taskLogger = taskId ? createTaskLogger(taskId) : logger;

  if (state.completionReason === "completed") {
    taskLogger.success(`Task completed! (${context.completionPromise} detected)`);
    await updateIssueLabel(issueNumber, "env:pr-created");

    const postApproval = await requestApproval({
      gateName: "Post-Completion",
      message: "Task appears complete. Review before creating PR.",
      autoMode: context.autoMode,
      scratchpadPath: context.scratchpadPath,
    });

    if (postApproval === "abort") {
      state.completionReason = "aborted";
    } else {
      taskLogger.success(`Orchestration complete after ${context.iteration} iterations`);
      if (eventBus) printEventSummary(eventBus, taskId);

      // ★ 改善Issue自動作成（新規追加）
      if (config.autoIssue?.enabled) {
        await createImprovementIssues(context, config, taskLogger);
      }

      if (context.createPR) {
        state.prResult = await handlePRCreation(context, taskId);
      }
    }
  } else if (state.completionReason === "error") {
    await updateIssueLabel(issueNumber, "env:blocked");
  }

  await finalizeReport(
    context,
    config,
    collector,
    eventBus,
    state.completionReason,
    state.prResult,
  );
}

/**
 * 改善Issueを自動作成
 * @param context ループコンテキスト
 * @param config 設定
 * @param taskLogger ロガー
 */
async function createImprovementIssues(
  context: LoopContext,
  config: Config,
  taskLogger: typeof logger,
): Promise<void> {
  try {
    taskLogger.info("改善提案を抽出中...");
    const suggestions = await extractImprovements(context);

    if (suggestions.length === 0) {
      taskLogger.info("改善提案が見つかりませんでした");
      return;
    }

    taskLogger.info(`${suggestions.length}件の改善提案を検出しました`);

    const issueGenerator = new IssueGenerator(config.autoIssue!);
    const createdIssues = await issueGenerator.createIssues(suggestions);

    if (createdIssues.length > 0) {
      taskLogger.success(`${createdIssues.length}件のIssueを作成しました`);
      for (const url of createdIssues) {
        taskLogger.success(`  → ${url}`);
      }
    } else {
      taskLogger.info("新規Issueは作成されませんでした（重複または優先度フィルタ）");
    }
  } catch (error) {
    taskLogger.error(
      "改善Issue作成中にエラーが発生しました",
      error instanceof Error ? error.message : String(error)
    );
    // エラーが発生してもループは正常完了
  }
}
```

---

## 6. テストコード

### 6.1 IssueGenerator単体テスト

**ファイル**: `src/output/issue-generator.test.ts`

```typescript
import { describe, it, expect, beforeEach, mock } from "bun:test";
import { IssueGenerator } from "./issue-generator.js";
import type { ImprovementSuggestion, IssueGeneratorConfig } from "../core/types.js";
import type { ProcessExecutor, ProcessResult } from "../core/process-executor.js";

// モックProcessExecutor
class MockProcessExecutor implements ProcessExecutor {
  private mockResults: Map<string, ProcessResult> = new Map();

  setMockResult(command: string, result: ProcessResult): void {
    this.mockResults.set(command, result);
  }

  async spawn(
    command: string,
    args: string[],
    options?: unknown
  ): Promise<ProcessResult> {
    const key = `${command} ${args.join(" ")}`;
    const result = this.mockResults.get(key);
    if (!result) {
      throw new Error(`No mock result for: ${key}`);
    }
    return result;
  }
}

describe("IssueGenerator", () => {
  let mockExecutor: MockProcessExecutor;
  let config: IssueGeneratorConfig;

  beforeEach(() => {
    mockExecutor = new MockProcessExecutor();
    config = {
      enabled: true,
      minPriority: "medium",
      labels: ["auto-generated", "improvement"],
      duplicateCheckEnabled: true,
    };
  });

  describe("createIssues", () => {
    it("should create issues for valid suggestions", async () => {
      const suggestions: ImprovementSuggestion[] = [
        {
          title: "Refactor SandboxAdapter",
          description: "High complexity detected",
          priority: "high",
          relatedFiles: ["src/adapters/sandbox-adapter.ts"],
        },
      ];

      // gh --version
      mockExecutor.setMockResult("gh --version", {
        stdout: "gh version 2.40.0",
        stderr: "",
        exitCode: 0,
      });

      // gh issue list (重複チェック)
      mockExecutor.setMockResult(
        'gh issue list --search in:title "Refactor SandboxAdapter" --state open --json title,number --limit 10',
        {
          stdout: "[]",
          stderr: "",
          exitCode: 0,
        }
      );

      // gh issue create
      mockExecutor.setMockResult(
        "gh issue create --title Refactor SandboxAdapter --body-file /tmp/orch-issue-body.md --label auto-generated,improvement,priority:high",
        {
          stdout: "https://github.com/owner/repo/issues/123",
          stderr: "",
          exitCode: 0,
        }
      );

      const generator = new IssueGenerator(config, mockExecutor);
      const result = await generator.createIssues(suggestions);

      expect(result).toEqual(["https://github.com/owner/repo/issues/123"]);
    });

    it("should skip low priority suggestions when minPriority is medium", async () => {
      const suggestions: ImprovementSuggestion[] = [
        {
          title: "Minor typo fix",
          description: "Fix typo in comment",
          priority: "low",
          relatedFiles: [],
        },
      ];

      // gh --version
      mockExecutor.setMockResult("gh --version", {
        stdout: "gh version 2.40.0",
        stderr: "",
        exitCode: 0,
      });

      const generator = new IssueGenerator(config, mockExecutor);
      const result = await generator.createIssues(suggestions);

      expect(result).toEqual([]);
    });

    it("should skip duplicate issues", async () => {
      const suggestions: ImprovementSuggestion[] = [
        {
          title: "Existing Issue",
          description: "This already exists",
          priority: "high",
          relatedFiles: [],
        },
      ];

      // gh --version
      mockExecutor.setMockResult("gh --version", {
        stdout: "gh version 2.40.0",
        stderr: "",
        exitCode: 0,
      });

      // gh issue list (重複あり)
      mockExecutor.setMockResult(
        'gh issue list --search in:title "Existing Issue" --state open --json title,number --limit 10',
        {
          stdout: JSON.stringify([{ title: "Existing Issue", number: 100 }]),
          stderr: "",
          exitCode: 0,
        }
      );

      const generator = new IssueGenerator(config, mockExecutor);
      const result = await generator.createIssues(suggestions);

      expect(result).toEqual([]);
    });

    it("should return empty array when disabled", async () => {
      const disabledConfig = { ...config, enabled: false };
      const suggestions: ImprovementSuggestion[] = [
        {
          title: "Test",
          description: "Test",
          priority: "high",
          relatedFiles: [],
        },
      ];

      const generator = new IssueGenerator(disabledConfig, mockExecutor);
      const result = await generator.createIssues(suggestions);

      expect(result).toEqual([]);
    });
  });
});
```

### 6.2 improvement-extractor単体テスト

**ファイル**: `src/utils/improvement-extractor.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { extractImprovements } from "./improvement-extractor.js";
import { writeFileSync, mkdirSync, rmSync } from "node:fs";
import type { LoopContext } from "../core/types.js";

describe("extractImprovements", () => {
  const testDir = ".test-improvement-extractor";
  const scratchpadPath = `${testDir}/scratchpad.md`;

  beforeEach(() => {
    mkdirSync(testDir, { recursive: true });
  });

  afterEach(() => {
    rmSync(testDir, { recursive: true, force: true });
  });

  it("should extract improvement suggestions from scratchpad", async () => {
    const scratchpadContent = `# Scratchpad

## Notes

### 改善提案
<!-- IMPROVEMENT_START priority:high category:refactoring -->
**タイトル**: SandboxAdapterの循環的複雑度が高い

**説明**: 
DockerAdapterのbuildDockerRunArgsメソッドが100行を超えており、
テストが困難になっています。

**関連ファイル**:
- \`src/adapters/docker-adapter.ts\`
<!-- IMPROVEMENT_END -->
`;

    writeFileSync(scratchpadPath, scratchpadContent);

    const context: LoopContext = {
      scratchpadPath,
      // ... その他のフィールド（テストでは不要）
    } as LoopContext;

    const suggestions = await extractImprovements(context);

    expect(suggestions).toHaveLength(1);
    expect(suggestions[0].title).toBe("SandboxAdapterの循環的複雑度が高い");
    expect(suggestions[0].priority).toBe("high");
    expect(suggestions[0].category).toBe("refactoring");
    expect(suggestions[0].relatedFiles).toEqual(["src/adapters/docker-adapter.ts"]);
  });

  it("should return empty array when no markers found", async () => {
    const scratchpadContent = `# Scratchpad

## Notes

通常のメモ
`;

    writeFileSync(scratchpadPath, scratchpadContent);

    const context: LoopContext = {
      scratchpadPath,
    } as LoopContext;

    const suggestions = await extractImprovements(context);

    expect(suggestions).toEqual([]);
  });
});
```

---

## 7. エラーハンドリング詳細

### 7.1 エラー分類と対処

| エラー分類 | 検出方法 | 対処方法 | ログレベル |
|-----------|---------|---------|-----------|
| gh CLI未インストール | `gh --version` 失敗 | Issue作成スキップ、警告ログ | WARN |
| GitHub認証エラー | `gh issue create` 失敗 | 該当Issue作成スキップ、エラーログ | ERROR |
| ネットワークエラー | `gh` コマンドタイムアウト | 該当Issue作成スキップ、エラーログ | ERROR |
| Scratchpad読み取り失敗 | `readScratchpad()` 例外 | 空配列返却、警告ログ | WARN |
| パースエラー | 正規表現マッチ失敗 | 該当マーカースキップ、警告ログ | WARN |
| 重複チェック失敗 | `gh issue list` 失敗 | Issue作成続行、警告ログ | WARN |

### 7.2 リトライ戦略

現在のフェーズではリトライは実装しません。将来的に以下を検討：

- GitHub API rate limit超過時: 指数バックオフでリトライ
- ネットワーク一時エラー: 最大3回リトライ

---

## 8. パフォーマンス考慮事項

### 8.1 処理時間見積もり

| 処理 | 想定時間 | 備考 |
|------|---------|------|
| Scratchpad読み取り | < 10ms | ファイルサイズ < 1MB想定 |
| 改善点抽出（正規表現） | < 50ms | マーカー数 < 100想定 |
| 重複チェック（1件） | 200-500ms | GitHub API呼び出し |
| Issue作成（1件） | 500-1000ms | GitHub API呼び出し |
| **合計（10件作成）** | **約10秒** | 並列化なし |

### 8.2 最適化案（将来）

- 重複チェックの並列化（Promise.all）
- Issue作成の並列化（ただしAPI rate limit注意）
- Scratchpadキャッシュ

---

## 9. セキュリティ考慮事項

### 9.1 インジェクション対策

- **コマンドインジェクション**: `--body-file` 使用により、Issue本文のシェルエスケープ問題を回避
- **パストラバーサル**: 一時ファイルパスは固定（`/tmp/orch-issue-body.md`）

### 9.2 認証情報管理

- gh CLIの認証情報は `gh auth login` で管理
- 本システムでは認証情報を保持しない

---

## 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|---------|--------|
| 1.0.0 | 2026-01-24 | 初版作成 | AI Assistant |
